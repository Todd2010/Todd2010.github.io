<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="本篇读书摘要大概有2万5千字，慢读需要3到4个小时。  
在原书通读过3到5遍后，每周再浏览一到两遍读书摘要，两个月后对Swift的基础知识算是能做到了然于胸了。">
<meta property="og:type" content="article">
<meta property="og:title" content="《The Swift Programming Language》读书摘要">
<meta property="og:url" content="http://todd2010.github.io/2016/10/04/006-Swift-Notes/index.html">
<meta property="og:site_name" content="Buddha's Temple">
<meta property="og:description" content="本篇读书摘要大概有2万5千字，慢读需要3到4个小时。  
在原书通读过3到5遍后，每周再浏览一到两遍读书摘要，两个月后对Swift的基础知识算是能做到了然于胸了。">
<meta property="og:image" content="http://7xth9g.com2.z0.glb.clouddn.com/Swift_Notes_001.png">
<meta property="og:updated_time" content="2016-12-02T09:43:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《The Swift Programming Language》读书摘要">
<meta name="twitter:description" content="本篇读书摘要大概有2万5千字，慢读需要3到4个小时。  
在原书通读过3到5遍后，每周再浏览一到两遍读书摘要，两个月后对Swift的基础知识算是能做到了然于胸了。">
<meta name="twitter:image" content="http://7xth9g.com2.z0.glb.clouddn.com/Swift_Notes_001.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 《The Swift Programming Language》读书摘要 | Buddha's Temple </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=56164015";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Buddha's Temple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                《The Swift Programming Language》读书摘要
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-04T10:07:00+08:00" content="2016-10-04">
              2016-10-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://7xth9g.com2.z0.glb.clouddn.com/Swift_Notes_001.png" alt="Swift_Notes_001.png">     </p>
<pre><code>本篇读书摘要大概有2万5千字，慢读需要3到4个小时。  
在原书通读过3到5遍后，每周再浏览一到两遍读书摘要，两个月后对Swift的基础知识算是能做到了然于胸了。     
</code></pre><a id="more"></a>    
<hr>
<h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><hr>
<p>Swift包含了C和Objecitve-C中所有的基础数据类型，<code>Int</code> 表示整型值；<code>Double</code> 和 <code>Float</code> 表示浮点型值；<code>Bool</code> 表示布尔型值；<code>String</code> 表示字符串型值；<code>Character</code> 表示字符型值。   </p>
<hr>
<p>Swift提供了三个的基本的集合类型：<code>Array</code>、<code>Dictionary</code>、<code>Set</code>。   </p>
<hr>
<p>在Swift中，如果你要处理的值不需要改变，那么使用常量可以让你的代码更加安全并且能更清晰的表达你的意图。   </p>
<hr>
<p>Swift增加了Objective-C中没有的高阶数据类型 —— 元祖（Tuple）。   </p>
<hr>
<p>Swift增加了Objective-C中没有的可选类型（Optional），用于处理值缺失的情况。   </p>
<hr>
<p>Swift是一门类型安全的语言，这意味着Swift可以让你清楚的知道值的类型。   </p>
<hr>
<p>常量和变量必须要在使用前声明，用 <code>let</code> 来声明常量，用 <code>var</code> 来声明变量。  </p>
<pre><code class="ObjC">let maximumNumberOfLoginAttempts = <span class="number">10</span>
var currentLoginAttempt = <span class="number">0</span>
</code></pre>
<hr>
<p>可以在一行中声明多个常量或变量，用逗号隔开。  </p>
<pre><code class="ObjC">var a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0.0</span>  <span class="comment">// a和b均为Int类型  c为Double类型</span>
</code></pre>
<hr>
<p>当你声明常量或变量的时候可以加上类型标注（type annotation），用来说明常量或变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加一个冒号和一个空格，然后再加上类型名称。  </p>
<pre><code class="ObjC">var a, b: Int, c: Double  <span class="comment">// a和b均为Int类型  c为Double类型</span>
</code></pre>
<p>一般来说，很少需要写类型标注。如果在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或变量的类型。   </p>
<hr>
<p>你可以用 <code>print(_:separator:terminator:)</code> 函数来输出常量或变量的值。<br><code>print(_:separator:terminator:)</code> 函数是一个用来输出一个或多个值到适当输出区的全局函数，在Xcode中，该函数将会把内容输出到控制台面板上。   </p>
<pre><code class="ObjC"><span class="comment">// print(_:separator:terminator:) 函数在标准库中的定义</span>
public func print(_ items: Any..., separator: String = <span class="keyword">default</span>, terminator: String = <span class="keyword">default</span>)

<span class="comment">/**
Parameters:
  - items: Zero or more items to print.
  - separator: A string to print between each item. The default is a single space (" ").
  - terminator: The string to print after all items have been printed. The default is a newline ("\n").
*/</span>
</code></pre>
<hr>
<p>Swift采用字符串插值（string interpolation）的方式把常量名或变量名当做占位符插入到字符串中，在运行时用当前常量或变量的值替换这些占位符。  </p>
<pre><code class="ObjC">let name = <span class="string">"Todd Cheng"</span>
let age = <span class="number">18</span>
print(<span class="string">"my name is \(name), my age is \(age)"</span>)
</code></pre>
<hr>
<p>Swift支持多行注释的嵌套。  </p>
<hr>
<p>你可以访问不同整数类型的 <code>max</code> 和 <code>min</code> 属性来获取对应整数类型的最大值和最小值。   </p>
<pre><code class="ObjC">let a = <span class="built_in">UInt8</span>.max  <span class="comment">// a的值为255，且a的类型为UInt8</span>
let b = <span class="built_in">UInt8</span>.min  <span class="comment">// b的值为0，且b的类型为UInt8</span>
</code></pre>
<hr>
<p>Swift提供了一个特殊的整数类型 <code>Int</code>，长度与当前平台的原生字长相同。   </p>
<ul>
<li>在32位平台设备上，<code>Int</code> 就是 <code>Int32</code>。  </li>
<li>在64位平台设备上，<code>Int</code> 就是 <code>Int64</code>。    </li>
</ul>
<p>Swift还提供了一个特殊的无符号整数类型 <code>UInt</code>，长度与当前平台的原生字长相同。  </p>
<ul>
<li>在32位平台设备上，<code>UInt</code> 就是 <code>UInt32</code>。  </li>
<li>在64位平台设备上，<code>UInt</code> 就是 <code>UInt64</code>。  </li>
</ul>
<p>尽量不要使用 <code>UInt</code> 或其他整数类型（如 <code>Int8</code>，<code>Int16</code>，<code>Int32</code>，<code>Int64</code>，<code>UInt8</code>，<code>UInt16</code>，<code>UInt32</code>，<code>UInt64</code> 等），最好使用 <code>Int</code>，即使你要存储的整数常量或者变量已知是非负的。统一使用 <code>Int</code> 可以提高代码的可复用性，避免不同类型之间的转换，并且可以匹配整数类字面量的类型推断。</p>
<hr>
<p>Swift提供了两种浮点数类型：  </p>
<ul>
<li><code>Double</code> 表示64位浮点数。可以保证精确到小数点后15位。   </li>
<li><code>Float</code> 表示32位浮点数。可以保证精确到小数点后6位。  </li>
</ul>
<pre><code class="ObjC">let a = <span class="number">1.01234567890123456789</span>
let b = <span class="number">1.0123456789012345</span>
let c = <span class="number">1.0123456789012346</span>

a == b  <span class="comment">// false</span>
a == c  <span class="comment">// true</span>
</code></pre>
<pre><code class="ObjC">let a: Float = <span class="number">1.12345678</span>
let b: Float = <span class="number">1.1234567</span>
let c: Float = <span class="number">1.1234568</span>

a == b  <span class="comment">// false</span>
a == c  <span class="comment">// true</span>
</code></pre>
<hr>
<p>Swift是一门类型安全的语言。类型安全的语言可以让你清楚的知道代码要处理的值的类型。比如代码需要一个 <code>String</code>，你绝不可能一不留神赋值一个 <code>Int</code>。   </p>
<hr>
<p>当你在声明常量或者变量的时候赋给它们一个字面量（literal value）即可触发类型推断。  </p>
<hr>
<p>整数字面量可以被写成：  </p>
<ul>
<li>十进制数，没有前缀。  </li>
<li>二进制数，前缀是 <code>0b</code>。  </li>
<li>八进制数，前缀是 <code>0o</code>。  </li>
<li>十六进制数，前缀是 <code>0x</code>。  </li>
</ul>
<hr>
<p>浮点数可以有一个可选的指数（exponent），用大写 <code>E</code> 或者小写 <code>e</code> 来表示。比如 <code>1.25E2</code> 就是 <code>125.0</code>，<code>1.25e-2</code> 就是 <code>0.0125</code>。  </p>
<hr>
<p>整数和浮点数可以添加下划线 <code>_</code> 来增强可读性，并且不会影响字面量的值。  </p>
<pre><code class="ObjC">let a = <span class="number">1000</span>_000<span class="number">.000</span>_000_1
let b = <span class="number">10000</span>_0000
</code></pre>
<hr>
<p>类型别名就是给现有的类型定义一个新名字，可以使用 <code>typealias</code> 关键字来定义类型别名。  </p>
<hr>
<p>如果你在需要使用 <code>Bool</code> 类型的地方使用了非 <code>Bool</code> 值，Swift的类型安全机制会报错。比如：  </p>
<pre><code class="ObjC">let i = <span class="number">1</span>
<span class="keyword">if</span> i { }  <span class="comment">// 这行代码不会通过编译，会报错   </span>
<span class="keyword">if</span> i == <span class="number">1</span> {}  <span class="comment">// 正确写法</span>
</code></pre>
<p>这种方式可以避免一些错误并保证这块代码的意图总是清晰的。  </p>
<hr>
<p>元组把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。  </p>
<pre><code class="ObjC">let http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
<span class="comment">// http404Error的类型为 (Int, String)</span>
</code></pre>
<p>通过下标来访问元组中的单个元素，下标从0开始。    </p>
<pre><code class="ObjC">let http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
http404Error<span class="number">.0</span>
http404Error<span class="number">.1</span>
</code></pre>
<hr>
<p>可以在定义元组的时候给每一个元素命名。   </p>
<pre><code class="ObjC">let http404Error = (code: <span class="number">404</span>, description: <span class="string">"Not Found"</span>)
http404Error.code
http404Error.description
</code></pre>
<hr>
<p>你可以将一个元组的内容分解成单独的常量或变量，然后再分别使用它们。  </p>
<pre><code class="ObjC">let (statusCode, statusMessage) = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
statusCode
statusMessage
</code></pre>
<p>如果你只需要一部分元组值，分解的时候可以把忽略的部分用下划线 <code>_</code> 标记。  </p>
<pre><code class="ObjC">let (_, justStatusMessage) = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
justStatusMessage
</code></pre>
<hr>
<p>使用可选类型来处理值可能缺失的情况。可选类型表示要么有值，为 <code>x</code>；要么没有值，为 <code>nil</code>。</p>
<hr>
<p>C和Objective-C中并没有可选类型这个概念。Objective-C中的 <code>nil</code> 只能用在对象身上，对于结构体、基本的C类型或者枚举类型都不起作用。对于这些类型，Objective-C一般会返回一个特殊值（比如 <code>NSNotFound</code> ）来暗示值缺失。这种办法是基于调用者知道并记得对特殊值判断的前提下的。然而，Swift的可选类型可以让你暗示任意值的缺失，并不需要一个特殊值。   </p>
<hr>
<p>如果你声明一个可选常量或者变量但是没有赋值，它会自动被设置为 <code>nil</code>。  </p>
<hr>
<p>Swift中的 <code>nil</code> 和Objective-C中 <code>nil</code> 并不一样。在Objective-C中，<code>nil</code> 是一个指向不存在对象的指针；在Swift中，<code>nil</code> 不是指针，它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型。  </p>
<hr>
<p>可以使用 <code>if</code> 语句让一个可选类型的常量或变量与 <code>nil</code> 比较是否相等来判断该可选常量或变量是否包含值。<br>如果可选类型有值，它将不等于 <code>nil</code>。并且当确定了一个可选类型确实包含值之后，可以在可选类型的常量或变量名字后面加一个感叹号 <code>!</code> 来获取其中的值，这被称为可选类型的强制解包。   </p>
<pre><code class="ObjC">let a = Int(<span class="string">"123"</span>)
<span class="keyword">if</span> a != <span class="literal">nil</span> {
    print(a!)
}
</code></pre>
<p>使用 <code>!</code> 来获取一个不存在的可选类型会导致运行时错误。因此，在使用 <code>!</code> 来强制解包之前，一定要确定可选类型包含一个非 <code>nil</code> 的值。  </p>
<hr>
<p>使用可选绑定来判断可选类型是否包含值，如果包含，就把值赋给一个临时的常量或变量。可选绑定可以用在 <code>if</code> 和 <code>while</code> 语句中。  </p>
<pre><code class="ObjC"><span class="keyword">if</span> let a = Int(<span class="string">"123"</span>) {
    print(a)
}
</code></pre>
<hr>
<p>你可以在一个 <code>if</code> 语句中包含多个可选绑定或多个布尔条件，使用逗号分开就行，只要有任意一个可选绑定的值为 <code>nil</code>，或者任意一个布尔条件的值为 <code>false</code>，则整个 <code>if</code> 语句的条件判断为 false。   </p>
<hr>
<p>在 <code>if</code> 条件语句中使用常量或变量来创建一个可选绑定，仅在 <code>if</code> 语句的句中才能获取到该常量或变量的值。<br>相反，在 <code>guard</code> 语句中使用常量或变量来创建一个可选绑定，仅在 <code>guard</code> 语句外且在语句后才能获取到该常量或变量的值。  </p>
<hr>
<p>有时候在代码中，在可选类型被第一次赋值之后，可以确定该可选类型总会有值，在这种情况下，每次都要判断和解包可选值是非常低效的。这时候可以把该可选类型声明为隐式解包可选类型（implicitly unwrapped optional），把普通可选类型后的问号（如 <code>String?</code>）改为感叹号（如 <code>String!</code>）来声明一个隐式解包可选类型。   </p>
<p>一个隐式解包可选类型其本质还是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次解包来获得可选值。  </p>
<pre><code class="ObjC">let optionalString: String? = <span class="string">"Optional String"</span>
print(optional!)

let implicitlyOptionalString: String! = <span class="string">"Implicitly Optional String"</span>
print(implicitlyOptionalString)
</code></pre>
<p>如果在隐式解包可选类型没有值的时候尝试取值，仍会触发运行时错误。这和在没有值的普通可选类型后面加感叹号是一样的。</p>
<hr>
<p>你仍然可以把隐式解包可选类型当做普通的可选类型，用 <code>if</code> 来判断是否有值，用可选绑定来解包可选值。   </p>
<hr>
<p>相对于可选类型用值的存在与缺失来表达一个函数是否包含满足条件的值，错误处理可以推断出函数调用失败的原因，并传播至程序的其他地方。    </p>
<hr>
<p>一个函数可以通过在声明中添加 <code>throws</code> 关键字来表明函数有可能会抛出错误消息。<br>当一个函数能抛出错误消息时，在调用该函数的时候应该前置 <code>try</code> 关键字来捕获错误消息。  </p>
<pre><code class="ObjC">func canThrowAnError() throws {
    <span class="comment">// 这个函数有可能抛出错误</span>
}

<span class="keyword">do</span> {
    try canThrowAnError()
    aFunc()
} catch xxxError.oneError {
    oneErrorHandle()
} catch xxxError.twoError {
    twoErrorHandle()
}
</code></pre>
<p>一个 <code>do</code> 语句创建了一个新的包含作用域，使得错误能被传播到一个或多个 <code>catch</code> 从句中。  </p>
<hr>
<p>可选类型能够让你判断值是否存在，你可以在代码中优雅的处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，代码就没办法继续执行，这时，你可以在代码中触发一个断言来结束代码运行并通过调试来找到无法继续执行下去的原因。<br>你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。断言会在运行时判断一个逻辑条件是否为true。如果条件判断为true，代码会继续进行；如果条件判断为false，应用程序将被终止。在调试环境下，你可以从Xcode中清楚的看到不合法的状态发生在哪里并以此来检查断言被触发时代码的状态。</p>
<hr>
<p>你可以使用全局函数 <code>assert(_:_:file:line:)</code> 来实现一个断言。  </p>
<pre><code class="ObjC"><span class="comment">// assert(_:_:file:line:) 函数在标准库中的定义</span>

<span class="comment">/// To check for invalid usage in Release builds, </span>
<span class="comment">/// see `precondition(_:_:file:line:)`.</span>

<span class="comment">/// * In playgrounds and `-Onone` builds (the default for Xcode's Debug</span>
<span class="comment">///   configuration): If `condition` evaluates to `false`, stop program</span>
<span class="comment">///   execution in a debuggable state after printing `message`.</span>

<span class="comment">/// * In `-O` builds (the default for Xcode's Release configuration), </span>
<span class="comment">/// `condition` is not evaluated, and there are no effects.</span>

<span class="comment">/// - Parameters:</span>
<span class="comment">///   - condition: The condition to test. `condition` is only evaluated in</span>
<span class="comment">///     playgrounds and `-Onone` builds.</span>
<span class="comment">///   - message: A string to print if `condition` is evaluated to `false`. The</span>
<span class="comment">///     default is an empty string.</span>
<span class="comment">///   - file: The file name to print with `message` if the assertion fails. The</span>
<span class="comment">///     default is the file where `assert(_:_:file:line:)` is called.</span>
<span class="comment">///   - line: The line number to print along with `message` if the assertion</span>
<span class="comment">///     fails. The default is the line number where `assert(_:_:file:line:)`</span>
<span class="comment">///     is called.</span>

public func assert(_ condition: @autoclosure () -&gt; Bool, 
                     _ message: @autoclosure () -&gt; String = <span class="keyword">default</span>, 
                          file: StaticString = <span class="meta">#file, </span>
                          line: <span class="built_in">UInt</span> = <span class="meta">#line)  </span>

let age = <span class="number">-3</span>
assert(age &gt; <span class="number">0</span>, <span class="string">"A person's age cannot be less than zero"</span>)  <span class="comment">// 不满足条件，断言被触发，应用终止。</span>
</code></pre>
<p>当代码使用优化编译的时候，断言将被禁用。例如在Xcode中，使用默认的 Target Release 配置选项来编译时，断言会被禁用。  </p>
<hr>
<h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><hr>
<p>Swift支持大部分的C语言运算符，且改进了许多特性来减少常规编码错误。如：  </p>
<ul>
<li>赋值符 <code>=</code> 不返回值。为了防止把想要判断相等运算符 <code>==</code> 的地方写成赋值运算符导致的错误。   </li>
<li>算术运算符（<code>+, -, *, /, %</code> 等）不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。（Swift允许你使用溢出运算符 <code>&amp;</code> 来实现溢出）  </li>
</ul>
<hr>
<p>运算符分为一元、二元和三元运算符：  </p>
<ul>
<li>一元运算符操作一个操作数。如 <code>-a</code>，<code>+a</code>，<code>!a</code>，<code>a!</code> 等。   </li>
<li>二元运算符操作两个操作数。如 <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>=</code>等。  </li>
<li>三元运算符操作三个操作数。和C语言一样，Swift只有一个三元运算符，就是三目运算符（<code>a ? b : c</code>）。   </li>
</ul>
<hr>
<p>与C语言和Objective-C不同，Swift的赋值操作并不返回任何值。所以以下代码是错误的：  </p>
<pre><code class="ObjC"><span class="keyword">if</span> x = y { }  <span class="comment">// 错误代码，因为 x = y 并不返回任何值，而 if 后面需要一个逻辑布尔值。</span>
</code></pre>
<p>这个特性使你无法把 <code>==</code> 错写成 <code>=</code>。  </p>
<hr>
<p>与C语言和Objective-C不同的是，Swift默认情况下不允许在数值运算中出现溢出情况。但是你可以使用Swift的溢出运算符来实现溢出运算（如 <code>a &amp;+ b</code>）。   </p>
<hr>
<p><code>a % b</code>，当 <code>b</code> 为负数时，<code>b</code> 的符号会被忽略。也就是说，<code>a % b</code> 与 <code>a % -b</code> 的结果是一样的。    </p>
<pre><code class="ObjC"><span class="number">9</span> % <span class="number">4</span>    <span class="comment">// 1</span>
<span class="number">9</span> % <span class="number">-4</span>   <span class="comment">// 1</span>

<span class="number">-9</span> % <span class="number">4</span>    <span class="comment">// -1</span>
<span class="number">-9</span> % <span class="number">-4</span>   <span class="comment">// -1</span>
</code></pre>
<hr>
<p>复合赋值运算符（如 <code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code> 等）没有返回值。类似 <code>let b = a += 2</code> 这样的代码是错误的。   </p>
<hr>
<p>Swift提供了恒等 <code>===</code> 和不恒等 <code>!==</code> 这两个比较符来判断两个常量或变量是否引用了同一个对象实例。  </p>
<hr>
<p>当元组中的值可以比较时，你可以使用比较运算符来比较他们的大小。比如，<code>Int</code> 和 <code>Sting</code> 类型的值可以比较大小，所以类型为 <code>(Int, String)</code> 的元组也可以比较大小。相反，<code>Bool</code> 类型的值无法比较大小（但可以比较是否相等），也意味着存在 <code>Bool</code> 类型的元组也就无法比较大小（但可以比较是否相等）。<br>比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组就称之为相等。   </p>
<hr>
<p>Swift的标准库中只支持7个元素以内的元组来比较大小，如果元组中元素超过7个，则需要自己实现比较操作。  </p>
<hr>
<p>三目运算符（ <code>a ? b : c</code> ）提供了高效率且便捷的方式来表达二选一的概念。需要注意的是，过度使用三目运算符会使简洁的代码变得难懂，我们应该避免在一个语句中使用多个三目运算符。   </p>
<hr>
<p>空和运算符 <code>a ?? b</code> 将对可选类型 <code>a</code> 进行空判断，如果 <code>a</code> 包含值就进行解包，否则就返回一个默认值 <code>b</code>。<br><code>a</code> 必须是可选类型，默认值 <code>b</code> 的类型必须要和 <code>a</code> 存储的值的类型保持一致。   </p>
<hr>
<p>空和运算符 <code>a ?? b</code> 其实是对三目运算符 <code>a != nil ? a! : b</code> 的简洁写法。   </p>
<hr>
<p>Swift提供了两个方便表达一个区间的运算符：闭区间运算符 <code>a...b</code> 以及 半开区间运算符 <code>a..&lt;b</code>。     </p>
<p>半开区间运算符的实用性在于当你使用一个从0开始的列表时，可以非常方便的从0遍历到列表的长度。  </p>
<hr>
<p>逻辑运算符的操作对象是逻辑布尔值。<br>Swift支持C语言的三个标准逻辑运算符：  </p>
<ul>
<li>逻辑非 <code>!a</code>。  </li>
<li>逻辑与 <code>a &amp;&amp; b</code>。  </li>
<li>逻辑或 <code>a || b</code>。  </li>
</ul>
<p>逻辑与和逻辑或运算符是支持短路计算的。  </p>
<hr>
<h3 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h3><hr>
<p><code>String</code> 类型是一种快速、现代化的字符串实现。每一个字符串都是由编码无关的 <code>Unicode</code> 字符组成，并支持访问字符的多种 <code>Unicode</code> 表示形式。   </p>
<hr>
<p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的 <code>String</code> 实例。   </p>
<pre><code class="ObjC">var emptyString1 = <span class="string">""</span>          <span class="comment">// 空字符串字面量</span>
var emptyString2 = String()    <span class="comment">// 初始化方法</span>
<span class="comment">// emptyString1 与 emptyString2 均为空字符串并相等</span>
</code></pre>
<p>可以通过 <code>String</code> 中 <code>isEmpty</code> 属性来判断字符串是否为空：   </p>
<pre><code class="ObjC"><span class="keyword">if</span> emptyString1.isEmpty { }
</code></pre>
<hr>
<p>Swift中的 <code>String</code> 类型是值类型。也就是说，如果你创建了一个字符串，那么当其为其他常量或变量进行赋值操作，或在函数中传递时，会进行值拷贝。   </p>
<p>Swift编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着把字符串作为值类型的同时可以获得极高的性能。  </p>
<hr>
<p>可以通过 <code>for-in</code> 循环遍历字符串的 <code>characters</code> 属性来获取每一个字符的值。   </p>
<pre><code class="ObjC"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Todd"</span> { 
    print(character) 
}
</code></pre>
<hr>
<p>字符串可以通过传递一个 <code>Character</code> 数组来进行初始化：   </p>
<pre><code class="ObjC">let catCharacters: [Character] = [<span class="string">"C"</span>, <span class="string">"A"</span>, <span class="string">"T"</span>]
let catString = String(catCharacters)
</code></pre>
<hr>
<p>字符串可以通过加法运算符 <code>+</code> 来把两个字符串连接在一起：  </p>
<pre><code class="ObjC">let string1 = <span class="string">"Hello "</span>
let string2 = <span class="string">"Todd!"</span>
let string3 = string1 + string2
</code></pre>
<p>也可以通过加法赋值运算符 <code>+=</code> 来把一个字符串添加到一个已经存在的字符串变量上：   </p>
<pre><code class="ObjC">var string4 = <span class="string">"Welcome "</span>
string4 += <span class="string">"Todd!"</span>
</code></pre>
<p>还可以通过 <code>append()</code> 函数将一个字符附加到一个字符串变量的尾部：   </p>
<pre><code class="ObjC">var string5 = <span class="string">"Chen"</span>
var character: Character = <span class="string">"g"</span>  
string5.append(character)

<span class="comment">// 在Swift的标准库中，String 的 append(_:) 函数有两种定义。</span>
public mutating func append(_ c: Character)
public mutating func append(_ other: String)
</code></pre>
<hr>
<p><code>Unicode</code> 是一个国际标准，用于文本的编码和表示。它使你能够用标准的格式来表示来自任意语言几乎所有的字符。Swift的 <code>String</code> 和 <code>Character</code> 类型是完全兼容 <code>Unicode</code> 标准的。   </p>
<hr>
<p>字符串字面量的特殊字符：  </p>
<ul>
<li>转义字符：<code>\0</code>（空字符），<code>\\</code>（反斜线），<code>\t</code>（水平制表符），<code>\n</code>（换行符），<code>\r</code>（回车符），<code>\&quot;</code>（双引号），<code>\&#39;</code>（单引号）。   </li>
<li><code>Unicode</code> 标量：写成 <code>\u{n}</code>（<code>u</code> 为小写），其中 <code>n</code> 为任意一到八位十六进制数且可用的 <code>Unicode</code> 标量。   </li>
</ul>
<hr>
<p>每一个Swift的 <code>Character</code> 类型都代表一个可扩展的字符群集。一个可扩展的字符群集是一个或多个 <code>Unicode</code> 标量的有序排列。<br>比如，字符 <code>é</code> 可以用单一的 <code>Unicode</code> 标量 <code>\u{00E9}</code> 来表示。也可以用一个标准的字符 <code>e</code>  <code>\u{0065}</code> 加上一个急促重音 <code>\u{0301}</code> 来表示。    </p>
<hr>
<p>可以通过访问字符串的 <code>characters</code> 属性的 <code>count</code> 属性来获取字符串中 <code>Character</code> 值的数量。  </p>
<hr>
<p>可扩展的字符群集可以由一个或多个 <code>Unicode</code> 标量组合而成，这也就意味着相同字符的不同表示方式可能需要不同数量的内存空间来存储，所以Swift中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取到可扩展字符群集范围的时候，是无法计算出字符串中字符数量的。当你在处理一个字符串的时候，需要注意到 <code>characters</code> 属性的访问必须要遍历字符串中全部的 <code>Unicode</code> 标量才能确定字符的数量。   </p>
<hr>
<p>每一个 <code>String</code> 值都有一个关联的索引类型（<code>String.Index</code>），它对应着字符串中每一个 <code>Character</code> 的位置。<br>字符的不同表示方式可能会占用不同数量的内存空间，所以要知道 <code>Character</code> 的具体位置，就必须从 <code>String</code> 的开头遍历每一个 <code>Unicode</code> 标量直到结尾。因此，Swift的字符串不能用整型做索引。   </p>
<hr>
<p>使用 <code>startIndex</code> 属性可以获取一个 <code>String</code> 的第一个 <code>Character</code> 索引。<br>使用 <code>endIndex</code> 属性可以获取一个 <code>String</code> 的最后一个 <code>Character</code> 的后一个位置的索引。  </p>
<p><code>endIndex</code> 不能作为一个字符串的有效下标。  </p>
<p>如果 <code>String</code> 是空串，<code>startIndex</code> 与 <code>endIndex</code> 相等且都等于 <code>0</code>。   </p>
<hr>
<p>通过调用 <code>String</code> 的 <code>index(before:)</code> 和 <code>index(after:)</code> 函数可以立即得到前面一个或后面一个索引。<br>还可以通过调用 String 的 index(_:offsetBy:) 函数来获取对应偏移量的索引。  </p>
<p>有了索引之后，可以通过下标语法来获取对应索引位置的 <code>Character</code>。  </p>
<pre><code class="ObjC">let name = <span class="string">"Todd"</span>

name[name.startIndex]  <span class="comment">// T</span>
name[name.endIndex]  <span class="comment">// 报错</span>

let aIndex = name.index(after: name.startIndex)
let bIndex = name.index(before: name.endIndex)
name[aIndex]  <span class="comment">// o</span>
name[bIndex]  <span class="comment">// d</span>

let cIndex = name.index(name.startIndex, offsetBy:<span class="number">2</span>)
name[cIndex]  <span class="comment">// d</span>
</code></pre>
<hr>
<p>使用 <code>characters</code> 属性的 <code>indices</code> 属性会创建一个包含全部索引的范围，用来在一个字符串中访问单个字符。  </p>
<pre><code class="ObjC"><span class="keyword">for</span> index <span class="keyword">in</span> name.characters.indices {
   print(name[index])
}
</code></pre>
<hr>
<p>你可以使用 <code>startIndex</code> 和 <code>endIndex</code> 属性以及 <code>index(before:)</code>、<code>index(after:)</code> 和 <code>index(_:offsetBy:)</code> 函数在任意一个遵循 <code>Collection</code> 协议的类型里面，如上面的 <code>String</code>，也可以使用在 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中。  </p>
<hr>
<p>调用 <code>insert(_:at:)</code> 函数可以在一个字符串的指定索引位置插入一个字符。<br>调用 <code>insert(contentsOf:at:)</code> 函数可以在一个字符串的指定索引位置插入一个字符串。  </p>
<pre><code class="ObjC">var string = <span class="string">"Hello"</span>
string.insert(<span class="string">"!"</span>, at: string.endIndex)  <span class="comment">// Hello!</span>
string.insert(contentsOf: <span class="string">" Todd"</span>.characters, 
                      at: string.index(before: string.endIndex))  <span class="comment">// Hello Todd!</span>
</code></pre>
<hr>
<p>调用 remove(at:) 函数可以在一个字符串的指定索引位置删除一个字符。<br>调用 removeSubrange(_:) 函数可以在一个字符串的指定索引范围删除一个字符串。  </p>
<pre><code class="ObjC">var string = <span class="string">"Hello!"</span>
string.remove(at: string.index(before: string.endIndex))  <span class="comment">// Hello</span>

let range = string.startIndex...string.index(string.startIndex, offsetBy: <span class="number">2</span>)
string.removeSubrange(range)  <span class="comment">// lo</span>
</code></pre>
<hr>
<p>你可以使用 <code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code> 函数以及 <code>remove(at:)</code>、<code>removeSubrange(_:)</code> 函数在任意一个遵循 <code>RangeReplaceableCollection</code> 协议的类型里面，如上面的 <code>String</code>，也可以使用在 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中。   </p>
<hr>
<p>字符串/字符可以用等于操作符 <code>==</code> 和不等于操作符 <code>!=</code>。   </p>
<p>如果两个字符串/字符的可扩展字符群集是标准相等的，那就认为它们是相等的。因此，即使可扩展字符群集是由不同的 <code>Unicode</code> 标量组成，只要它们具有同样的语言意义和外观，就认为他们标准相等。  </p>
<pre><code class="ObjC">let a = <span class="string">"caf\u{00E9}"</span>
let b = <span class="string">"caf\u{0065}\u{0301}"</span>
a == b  <span class="comment">// true</span>
</code></pre>
<hr>
<p>通过调用 <code>hasPrefix(_:)</code> 和 <code>hasSuffix(_:)</code> 函数来检查字符串中是否拥有特定的前缀和后缀。  </p>
<p><code>hasPrefix(_:)</code> 和 <code>hasSuffix(_:)</code> 函数是在每个字符串中逐个字符比较其可扩展的字符群集是否标准相等。  </p>
<hr>
<p>Swift提供了三种方式来访问字符串的 <code>Unicode</code> 表示形式：  </p>
<ul>
<li>UTF-8，利用字符串的 <code>utf8</code> 属性进行访问。  </li>
<li>UTF-16，利用字符串的 <code>utf16</code> 属性访问。  </li>
<li>UTF-32，也就是 <code>Unicode</code> 标量。利用字符串的 <code>unicodeScalars</code> 属性访问。   </li>
</ul>
<hr>
<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><hr>
<p>Swift语言提供了 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 这三种基本的集合类型来存储数据。<br>数组 <code>Array</code> 是有序数据的集，字典 <code>Dictionary</code> 无序键值对的集，集合 <code>Set</code> 是无序无重复数据的集。  </p>
<hr>
<p><code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中存储的数据值类型必须明确。这意味着我们不能把不正确的数据类型放入其中，同时也说明了我们完全可以对取回的值的类型非常自信。  </p>
<hr>
<p>在我们不需要改变集合的时候尽量应该创建不可变集合，这样不仅可以有更好的性能优化，还能更加清晰的表达你的意图。  </p>
<hr>
<p>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在数组中的不同位置。  </p>
<hr>
<p>写Swift数组应该遵循像 <code>Array&lt;Element&gt;</code> 这样的形式，其中 <code>Element</code> 是这个数组中唯一允许存在的数据类型。也可是使用 <code>[Element]</code> 这样的简单语法。在实际编写代码的过程中，推荐使用 <code>[Element]</code> 这种写法。   </p>
<hr>
<p>通过构造函数创建一个空数组：   </p>
<pre><code class="ObjC">var someInts = [Int]()
</code></pre>
<hr>
<p>清空数组（置空）：  </p>
<pre><code class="ObjC">var someInts = [Int]()
someInts.append(<span class="number">3</span>)
someInts = []
</code></pre>
<hr>
<p>创建特定大小并有默认值的数组：  </p>
<pre><code class="ObjC">var threeDoubles = Array(repeating: <span class="number">0.0</span>, count: <span class="number">3</span>)  <span class="comment">// [0.0, 0.0, 0.0]</span>
</code></pre>
<p>通过两个数组相加创建一个数组：  </p>
<pre><code class="ObjC">var oneDouble = [Double]()
oneDouble.append(<span class="number">1.0</span>)

let twoDoubles = Array(repeating: <span class="number">2.0</span>, count: <span class="number">2</span>)

let threeDoubles = oneDouble + twoDoubles  <span class="comment">// [1.0, 2.0, 2.0]</span>
</code></pre>
<p>用数组字面量来创建数组：   </p>
<pre><code class="ObjC">var shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]

<span class="comment">// 如果数组字面量中有多种数据类型，则必须采用类型标注</span>
var one: [Any] = [<span class="number">1</span>, <span class="number">1.0</span>, <span class="string">"一"</span>]
</code></pre>
<hr>
<p>通过访问数组的 <code>count</code> 属性来获取数组中数据项的数量。  </p>
<p>通过访问数组的 <code>isEmpty</code> 属性来判断数组是否为空。   </p>
<hr>
<p>数组的增删改查：  </p>
<pre><code class="ObjC">var array = [Int]()

<span class="comment">// 增</span>
array.append(<span class="number">1</span>)
array.append(contentsOf: <span class="number">2.</span>.<span class="number">.5</span>)  <span class="comment">// array.append(contentsOf: [2, 3, 4, 5])</span>
array += [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  <span class="comment">// array += 6...8</span>

<span class="comment">// 删</span>
array.remove(at: <span class="number">0</span>)  <span class="comment">// 删除第一个</span>
array.removeFirst()  <span class="comment">// 删除第一个</span>
array.removeLast()  <span class="comment">// 删除最后一个</span>
array.removeFirst(<span class="number">2</span>)  <span class="comment">// 删除前两个</span>
array.removeLast(<span class="number">2</span>)  <span class="comment">// 删除后两个</span>
array.removeSubrange(<span class="number">2.</span>.<span class="number">.5</span>)  <span class="comment">// 删除第2个到第5个</span>

<span class="comment">// 改</span>
array[<span class="number">0</span>] = <span class="number">-1</span>
array[<span class="number">1.</span>.<span class="number">.3</span>] = [<span class="number">9</span>]
array.insert(<span class="number">-2</span>, at: <span class="number">0</span>)
array.insert(contentsOf: <span class="number">10.</span>.<span class="number">.15</span>, at: array.count)

<span class="comment">// 查</span>
array[<span class="number">0</span>]
array[<span class="number">0.</span>.<span class="number">.3</span>]
</code></pre>
<hr>
<p>使用 <code>for-in</code> 循环来遍历数组中的所有数据项。  </p>
<p>如果你同时需要数据项和索引值，可以使用 <code>enumerated()</code> 函数来进行数组遍历。<code>enumerated()</code> 函数返回一个由每一个索引值和数据值组成的元组的新数组。  </p>
<pre><code class="ObjC"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() {
    print(index)
    print(value)
}
</code></pre>
<hr>
<p>集合 <code>Set</code> 用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。  </p>
<hr>
<p>一个类型要存储在集合中，该类型必须是可哈希化的。也就是说，该类型必须能提供一个方法来计算它的哈希值。  </p>
<p>哈希值是 <code>Int</code> 类型的。相等对象的哈希值也相同。比如，若 a == b，则 a.hashValue == b.hashValue。  </p>
<pre><code class="ObjC">let a = <span class="number">1</span>
let b = <span class="number">1</span>
a == b  <span class="comment">// true</span>
a.hashValue == b.hashValue  <span class="comment">// true</span>
</code></pre>
<hr>
<p>Swift的所有基本类型（如 <code>String</code>，<code>Int</code>，<code>Double</code>，<code>Bool</code> 等）默认都是可哈希化的，可以作为集合中值的类型或者字典中键的类型。  </p>
<p>没有关联值的枚举成员值默认也是可哈希化的。    </p>
<pre><code class="ObjC"><span class="keyword">enum</span> Direction {
    <span class="keyword">case</span> east
    <span class="keyword">case</span> sourth
    <span class="keyword">case</span> west
    <span class="keyword">case</span> north
}

Direction.sourth.hashValue  <span class="comment">// 1</span>
</code></pre>
<hr>
<p>可以使用你自定义的类型作为集合中值的类型或者字典中键的类型，但是自定义的类型必须遵守 <code>Hashable</code> 协议。符合 <code>Hashable</code> 协议的类型需要提供一个类型为 <code>Int</code> 的 <code>hashValue</code> 属性。<br>由于 <code>Hashable</code> 协议还遵守了 <code>Equatable</code> 协议，所以还需要提供一个对相等运算符 <code>==</code> 的实现。  </p>
<hr>
<p>写Swift集合应该遵循像 <code>Set&lt;Element&gt;</code> 这样的形式，其中 <code>Element</code> 表示 <code>Set</code> 中允许存储的类型。和数组不同的是，集合没有等价的简写形式。   </p>
<hr>
<p>通过构造函数创建一个空集合：  </p>
<pre><code class="ObjC">var letters = Set&lt;Character&gt;()
</code></pre>
<hr>
<p>清空集合中的内容：  </p>
<pre><code class="ObjC">var letters = Set&lt;Character&gt;()
letters.insert(<span class="string">"a"</span>)
letters = []
</code></pre>
<hr>
<p>用数组字面量来创建集合：  </p>
<pre><code class="ObjC">var favoriteGenres: Set&lt;String&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip pop"</span>]
</code></pre>
<p>一个 <code>Set</code> 类型不能从数组字面量中被单独推断出来，因此 <code>Set</code> 类型必须显示声明。然而，由于Swift的类型推导功能，如果你想使用一个数组字面量构造一个 <code>Set</code> 并且该数组字面量中所有的元素类型都相同，那么你无须写出 <code>Set</code> 的具体类型。上面的代码可以简化为：  </p>
<pre><code class="ObjC">var favoriteGenres: Set = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip pop"</span>]
</code></pre>
<hr>
<p>通过访问集合的 <code>count</code> 属性来获取集合中元素的数量。  </p>
<p>通过访问集合的 <code>isEmpty</code> 属性来判断集合是否为空。  </p>
<hr>
<p>对 Set 的基本操作：  </p>
<pre><code class="ObjC">var favoriteGenres: Set = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip pop"</span>]

<span class="comment">// 添加一个新元素</span>
favoriteGenres.insert(<span class="string">"Jazz"</span>)

<span class="comment">// 删除一个元素</span>
<span class="comment">// 如果Set中存在想要删除的元素，则返回该元素值，否则返回nil</span>
<span class="keyword">if</span> let removedGenre = favoriteGenres.remove(<span class="string">"Rock"</span>) { }

<span class="comment">// Set中是否包含某个元素</span>
favoriteGenres.contains(<span class="string">"Classical"</span>)
</code></pre>
<hr>
<p>使用 <code>for-in</code> 循环来遍历集合。  </p>
<p>Swift中的 <code>Set</code> 类型没有确定的顺序，为了按照特定的顺序来遍历一个 <code>Set</code> 中的值，可以使用 <code>sorted()</code> 函数，它将返回一个有序数组，这个数组的元素排列由操作符 <code>&lt;</code>（升序） 对元素进行比较的结果来确定的。   </p>
<pre><code class="ObjC"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres.sorted() {
    print(genre)
}
</code></pre>
<hr>
<p>两个集合基本操作：  </p>
<pre><code class="ObjC">let aSet: Set = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]
let bSet: Set = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]

<span class="comment">// a与b的并集</span>
aSet.union(bSet)

<span class="comment">// a与b的交集</span>
aSet.intersection(bSet)

<span class="comment">// 在集合a中，不在集合b中</span>
aSet.subtracting(bSet)

<span class="comment">// 两个集合是否相等（两个集合是否包含全部相同的元素）</span>
aSet == bSet

<span class="comment">// 一个集合是否是另一个集合的子集</span>
aSet.isSubset(of: bSet)

<span class="comment">// 一个集合是否是另一个集合的超集</span>
aSet.isSuperset(of: bSet)
</code></pre>
<hr>
<p>字典是一种存储同一类型的值的容器。每个值都关联唯一的键。<br>和数组不同的是，字典中的数据项并没有具体的顺序。  </p>
<hr>
<p>用 <code>Dictionary&lt;Key, Value&gt;</code> 的这种写法来定义Swift中的字典，其中 <code>Key</code> 是字典中键的数据类型，<code>Value</code> 是字典中值的数据类型。也可以使用 <code>[Key: Value]</code> 这样的简化形式来创建一个字典类型。推荐使用后者简化写法。   </p>
<hr>
<p>字典中 <code>Key</code> 的类型必须遵守 <code>Hashable</code> 协议。   </p>
<hr>
<p>利用构造函数创建一个空字典：   </p>
<pre><code class="ObjC">var namesOfIntegers = [Int: String]()
</code></pre>
<hr>
<p>清空字典中的内容：  </p>
<pre><code class="ObjC">var namesOfIntegers = [Int: String]()
namesOfIntegers[<span class="number">6</span>] = <span class="string">"six"</span>
namesOfIntegers = [:]
</code></pre>
<hr>
<p>使用字典字面量来创建字典：  </p>
<pre><code class="ObjC">var ab = [<span class="string">"aaa"</span>: <span class="string">"AAA"</span>, <span class="string">"bbb"</span>: <span class="string">"BBB"</span>]

<span class="comment">// 如果键的类型或者值的类型不一致，则必须采用类型标注</span>
var person: [String: Any] = [<span class="string">"name"</span>: <span class="string">"Todd"</span>, <span class="string">"age"</span> : <span class="number">18</span>]
</code></pre>
<hr>
<p>通过访问字典的 <code>count</code> 属性来获取字典中键值对的数量。</p>
<p>通过访问字典的 <code>isEmpty</code> 属性来判断字典是否为空。  </p>
<hr>
<p>对于字典的一些基本操作：  </p>
<pre><code class="ObjC">var namesOfIntegers = [Int: String]()

<span class="comment">// 增/改</span>
namesOfIntegers[<span class="number">1</span>] = <span class="string">"one"</span>
namesOfIntegers[<span class="number">2</span>] = <span class="string">"two"</span>
namesOfIntegers[<span class="number">3</span>] = <span class="string">"three"</span>

<span class="comment">// 如果键不存在就新增，如果存在就修改</span>
<span class="comment">// updateValue(_:forKey:)有返回值，返回更新值之前的原值</span>
namesOfIntegers.updateValue(<span class="string">"Three"</span>, forKey: <span class="number">3</span>)  <span class="comment">// three</span>
namesOfIntegers.updateValue(<span class="string">"Four"</span>, forKey: <span class="number">4</span>)  <span class="comment">// nil</span>

<span class="comment">// 查（通过下标语法来获取键对应的值）</span>
namesOfIntegers[<span class="number">4</span>]
namesOfIntegers[<span class="number">5</span>]

<span class="comment">// 删</span>
namesOfIntegers[<span class="number">4</span>] = <span class="literal">nil</span>

<span class="comment">// removeValue(forKey:)有返回值，返回被删除的值</span>
namesOfIntegers.removeValue(forKey: <span class="number">3</span>)  <span class="comment">// Three</span>
namesOfIntegers.removeValue(forKey: <span class="number">5</span>)  <span class="comment">// nil</span>
</code></pre>
<hr>
<p>使用 for-in 循环来遍历字典中的键值对：   </p>
<pre><code class="ObjC"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> namesOfIntegers {
    print(key)
    print(value)
}
</code></pre>
<hr>
<p>通过访问字典的 <code>keys</code> 和 <code>values</code> 属性可以获取到字典所有的键和值。  </p>
<p>Swift的字典类型是无序集合类型，为了以特定顺序遍历字典的键或值，可以对字典的 <code>keys</code> 或 <code>values</code> 属性使用 <code>sorted()</code> 函数。  </p>
<hr>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><hr>
<p>使用 <code>for-in</code> 循环来遍历一个集合中的所有元素，如数字范围、字符串中的字符、数组中的元素以及字典中的键值对等。   </p>
<pre><code class="ObjC"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">.5</span> { }
<span class="keyword">for</span> character <span class="keyword">in</span> string.characters { }
<span class="keyword">for</span> name <span class="keyword">in</span> nameArray { }
<span class="keyword">for</span> (key, value) <span class="keyword">in</span> infoDictionary { }
</code></pre>
<p>如果不需要区间序列内每一项的值，可以使用下划线 <code>_</code> 来忽略这个值。  </p>
<pre><code class="ObjC"><span class="comment">// 打印5次</span>
<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">.5</span> { 
    print(<span class="string">"Todd"</span>)
}
</code></pre>
<hr>
<p><code>while</code> 循环会一直运行一段语句直到条件变成false。这类循环适合使用在迭代次数未知的情况下。   </p>
<p>Swift提供两种 <code>while</code> 循环形式：   </p>
<ul>
<li><code>while</code> 循环。每次在循环开始时计算条件是否符合。   </li>
<li><code>repeat - while</code> 循环。每次在循环结束时计算条件是否符合。  </li>
</ul>
<hr>
<p>Swift提供了两种条件分支语句：<code>if</code> 语句和 <code>switch</code> 语句。当条件较为简单且可能的情况很少时，使用 <code>if</code> 语句；当条件较复杂、有更多排列组合的时候 <code>switch</code> 语句更适用。并且，<code>switch</code>语句在需要用到模式匹配的情况下会更有用。   </p>
<hr>
<p><code>switch</code> 语句会尝试把某个值与若干个模式进行匹配。根据第一个匹配成功的模式，<code>switch</code> 语句会执行对应的代码。   </p>
<hr>
<p><code>switch</code> 语句必须是完备的。这就是说，每一个可能的值都必须至少有一个分支与之对应。在某些不可能涵盖所有值的情况下，可以使用默认分支来涵盖其他所有没有对应的值，这个默认分支必须在 <code>switch</code> 语句的最后面。  </p>
<hr>
<p>与C和Objective-C中的 <code>switch</code> 语句不同，在Swift中，当匹配的 <code>case</code> 分支中的代码执行完毕后，程序会立即终止 <code>switch</code> 语句，并不会继续执行下一个 <code>case</code> 分支。也就是说，不需要在 <code>case</code> 分支中显式的使用 <code>break</code> 语句。这使得 <code>switch</code> 语句更安全、更易用，也能避免因忘记写 <code>break</code> 语句而产生的错误。    </p>
<p>如果想要显式贯穿 <code>case</code> 分支，可以使用 <code>fallthrough</code> 语句。  </p>
<p>虽然在 <code>case</code> 语句后 <code>break</code> 不是必须的，但是依然可以在 <code>case</code> 分支中的代码执行完毕前使用  <code>break</code> 跳出 <code>switch</code> 语句。  </p>
<hr>
<p>每一个 <code>case</code> 分支都必须包含至少一条语句。像下面这样的代码是无效的，因为第一个 <code>case</code> 分支是空的：  </p>
<pre><code class="ObjC">let character: Character = <span class="string">"a"</span>

<span class="keyword">switch</span> character {
<span class="keyword">case</span> <span class="string">"a"</span>:  <span class="comment">// 编译报错</span>
<span class="keyword">case</span> <span class="string">"A"</span>:
    print(<span class="string">"The letter is A"</span>)
<span class="keyword">default</span>:
    print(<span class="string">"Other letters"</span>)
}
</code></pre>
<hr>
<p>如上代码，为了让单个 <code>case</code> 同时匹配 <code>a</code> 和 <code>A</code>，可以将这两个值组成一个复合匹配，用逗号分开：    </p>
<pre><code class="ObjC">let character: Character = <span class="string">"a"</span>

<span class="keyword">switch</span> character {
<span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"A"</span>:
    print(<span class="string">"The letter is a/A"</span>)
<span class="keyword">default</span>:
    print(<span class="string">"Other letters"</span>)
}
</code></pre>
<hr>
<p><code>case</code> 分支的模式可以是一个值区间。  </p>
<hr>
<p>使用元组在同一个 switch 语句中匹配多个值。元组中的元素可以是值，也可以是区间。还可以使用下划线 <code>_</code> 来匹配所有可能的值。  </p>
<pre><code class="ObjC">let point = (<span class="number">0</span>, <span class="number">1</span>)

<span class="keyword">switch</span> point {
<span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):
    print(<span class="string">"origin"</span>)
<span class="keyword">case</span> (_, <span class="number">0</span>):
    print(<span class="string">"x axis"</span>)
<span class="keyword">case</span> (<span class="number">0</span>, _):
    print(<span class="string">"y axis"</span>)
<span class="keyword">case</span> (<span class="number">-2.</span>.<span class="number">.2</span>, <span class="number">-2.</span>.<span class="number">.2</span>):
    print(<span class="string">"inside the 4*4 box"</span>)
<span class="keyword">default</span>:
    print(<span class="string">"outside the 4*4 box"</span>)
}
</code></pre>
<p>从这个例子中可以看出，Swift允许多个 <code>case</code> 匹配同一个值。但是，如果存在多个匹配，那么只会执行第一个被匹配到的 <code>case</code> 分支，剩下分支都会被忽视掉。  </p>
<hr>
<p><code>case</code> 分支允许将匹配的值绑定到一个临时的常量或变量，并且在 <code>case</code> 分支体内使用 —— 这种行为被称为值绑定 <code>value binding</code>。   </p>
<pre><code class="ObjC">let point = (<span class="number">2</span>, <span class="number">0</span>)

<span class="keyword">switch</span> point {
<span class="keyword">case</span> (let x, <span class="number">0</span>):
    print(<span class="string">"x axis and x is \(x)"</span>)
<span class="keyword">case</span> (<span class="number">0</span>, let y):
    print(<span class="string">"y axis and y is \(y)"</span>)
<span class="keyword">case</span> let (x, y):
    print(<span class="string">"x is \(x) and y is \(y)"</span>)
}
</code></pre>
<p>可以看到，这个 <code>switch</code> 语句不包含默认分支。这是因为最后一个 <code>case</code> 声明了一个可以匹配余下所有值的元组。这使得 <code>switch</code> 语句已经完备了，因此不需要默认分支。  </p>
<hr>
<p><code>case</code> 分支的模式可以使用 <code>where</code> 语句来判断额外的条件。  </p>
<pre><code class="ObjC">let point = (<span class="number">2</span>, <span class="number">2</span>)

<span class="keyword">switch</span> point {
<span class="keyword">case</span> let (x, y) where x == y:
    print(<span class="string">"on the line x = y"</span>)
<span class="keyword">case</span> let (x, y) where x == -y:
    print(<span class="string">"on the line x = -y"</span>)
<span class="keyword">case</span> let (x, y):
    print(<span class="string">"x is \(x) and y is \(y)"</span>)
}
</code></pre>
<hr>
<p>当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个 <code>case</code> 后面，并且用逗号隔开。当 <code>case</code> 后面的任意一种模式匹配的时候，这条分支就会被匹配。并且，如果匹配列表过长，还可以分行书写。   </p>
<pre><code class="ObjC">let character: Character = <span class="string">"e"</span>

<span class="keyword">switch</span> character {
<span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>:
    print(<span class="string">"\(character) is a vowel"</span>)
<span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,
     <span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>,
     <span class="string">"z"</span>:
    print(<span class="string">"\(character) is a consonant"</span>)
<span class="keyword">default</span>:
    print(<span class="string">"\(character) is not a vowel or a consonant"</span>)
}
</code></pre>
<hr>
<p>控制转移语句可以改变代码的执行顺序，通过它可以实现代码的跳转。Swift有五种控制转移语句：  </p>
<ul>
<li><code>continue</code>：告诉一个循环体立刻停止本次循环，重新开始下次循环，但并不会离开整个循环体。    </li>
<li><code>break</code>：会立刻结束整个控制流的执行。如果想要更早的结束一个 <code>switch</code> 代码块或者一个循环体时，可以使用 <code>break</code> 语句。  </li>
<li><code>fallthrough</code>   </li>
<li><code>return</code>  </li>
<li><code>throw</code>   </li>
</ul>
<hr>
<p>在Swift中，可以在循环体和条件语句中嵌套循环体和条件语句来创造复杂的控制流结构。并且循环体和条 件语句都可以使用 <code>break</code> 语句来提前结束整个代码块。因此，显式地指明 <code>break</code> 语句想要终止的是哪个循环体或者条件语句会很有用。类似地，如果你有许多嵌套的循环体，显式指明 <code>continue</code> 语句想要影响哪一个循环体也会非常有用。  </p>
<p>为了实现这个目的，可以使用标签来标记一个循环体或者条件语句，对于一个条件语句，可以使用 <code>break</code> 加标签的方式来结束这个被标记的语句。对于一个循环语句，可以使用 <code>break</code> 或者 <code>continue</code> 加标签来结束或者继续这条被标记语句的执行。  </p>
<p>声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签作为这个语句的前导关键字，并且该标签后面跟一个冒号。下面是一个针对 <code>while</code> 循环体的标签语法，同样的规则适用于所有的循环体和条件语句。</p>
<pre><code class="ObjC"><span class="comment">// 格式</span>
labelName: <span class="keyword">while</span> condition {
    statements
}

<span class="comment">// 例子</span>
oneRoop: <span class="keyword">while</span> <span class="literal">true</span> {
    twoRoop: <span class="keyword">while</span> <span class="literal">true</span> {
        var i = Int(arc4random_uniform(<span class="number">10</span>))
        var j = Int(arc4random_uniform(<span class="number">10</span>))
        <span class="keyword">if</span> i == <span class="number">5</span> {
            <span class="keyword">break</span> oneRoop
        }
        <span class="keyword">if</span> j == <span class="number">5</span> {
            <span class="keyword">break</span> twoRoop
        }
    }
}
</code></pre>
<hr>
<p>像 <code>if</code> 语句一样，<code>guard</code> 的执行取决于其后表达式的布尔值。不同于 <code>if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 从句，如果条件不为真则执行 <code>else</code> 从句中的代码。   </p>
<p>如果 <code>guard</code> 语句的条件被满足，则继续执行 <code>guard</code> 语句大括号后的代码。如果条件不被满足，在 <code>else</code> 分支上的代码就会被执行，这个分支必须转移控制以退出 <code>guard</code> 语句出现的代码段。它可以用控制转移语句如 <code>return</code>，<code>break</code>，<code>continue</code> 以及 <code>throw</code>，或者调用一个不返回的方法或函 数，例如 <code>fatalError()</code>。   </p>
<p>相比于可以实现同样功能的 <code>if</code> 语句，使用 <code>guard</code> 语句会提升代码的可读性。它可以使代码连贯的被执行而不需要将它包含在 <code>else</code> 语句块中。  </p>
<pre><code class="ObjC">func greet(person: [String: String]) {
    guard let name = person[<span class="string">"name"</span>] <span class="keyword">else</span> { <span class="keyword">return</span> }
    print(<span class="string">"Hello \(name)"</span>)
    guard let location = person[<span class="string">"location"</span>] <span class="keyword">else</span> { <span class="keyword">return</span> }
    print(<span class="string">"I hope the weather is nice in \(location)."</span>)
}
</code></pre>
<hr>
<p>在Swift开发中，为了适配不同的操作系统版本，有时候必须要对API的兼容性做处理。  </p>
<p>在Objective-C中，通常采用如下三种方式：   </p>
<pre><code class="ObjC"><span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].systemVersion.intValue &gt;= <span class="number">8</span>) { }

<span class="keyword">if</span> (<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(xxxAPI)) { }

<span class="meta">#if __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 70000</span>
    xxxx
<span class="meta">#else</span>
    xxxx
<span class="meta">#endif</span>
</code></pre>
<p>对Swift来说，我们可以在 <code>if</code> 或 <code>guard</code> 条件语句中使用可用性条件 <code>#available</code> 在运行时判断不同的平台下，做不同的逻辑处理。  </p>
<pre><code class="ObjC"><span class="keyword">if</span> <span class="meta">#available(iOS 10.0, *) {</span>
    <span class="comment">// iOS10及更高的系统下运行</span>
} <span class="keyword">else</span> { 
    <span class="comment">// iOS10以下系统下运行 </span>
}

guard <span class="meta">#available(iOS 9.0, *) else { return xxx }</span>
</code></pre>
<p>最后一个参数 <code>*</code> 是必须的，用于指定在所有其它平台中（如 <code>macOS</code>，<code>watchOS</code>，<code>tvOS</code> 等）。  </p>
<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><hr>
<p>如果函数没有参数，函数名后的一对圆括号还是不能省略的。当该无参函数被调用时，也需要在函数名后写上一对圆括号。   </p>
<p>没有定义返回值类型的函数会返回一个特殊的 <code>Void</code> 值，它其实是一个空的元组 <code>()</code>，没有任何元素。  </p>
<hr>
<p>使用元组可以让函数返回多个值。   </p>
<pre><code class="ObjC"><span class="comment">// 函数的定义</span>
func minAndMax(array: [Int]) -&gt; (min: Int, max: Int)? {
    guard let firstNumber = array.first <span class="keyword">else</span> { <span class="keyword">return</span> <span class="literal">nil</span> }

    var currentMin = firstNumber
    var currentMax = firstNumber

    <span class="keyword">for</span> number <span class="keyword">in</span> array {
        <span class="keyword">if</span> currentMin &gt; number {
            currentMin = number
        } <span class="keyword">else</span> <span class="keyword">if</span> currentMax &lt; number {
            currentMax = number
        }
    }

    <span class="keyword">return</span> (currentMin, currentMax)
}



<span class="comment">// 函数的调用</span>
<span class="keyword">if</span> let a = minAndMax(array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) {
    <span class="comment">// 元组成员的名字已经在函数的返回值类型中定义过了</span>
    a.min
    a.max
}
</code></pre>
<hr>
<p>每个函数参数都有一个参数标签以及一个参数名称。参数标签是在调用函数的时候使用；参数名称在函数的实现中使用。默认情况下，参数名称就是参数标签。   </p>
<pre><code class="ObjC"><span class="comment">// 参数标签就是参数名称</span>
func addTwoNumbers(num1: Int, num2: Int) -&gt; Int {
    <span class="keyword">return</span> num1 + num2
}
addTwoNumbers(num1: <span class="number">10</span>, num2: <span class="number">20</span>)

<span class="comment">// 指定参数标签（不再使用参数名称作为参数标签）</span>
func addTwoNumbers(oneNumber num1: Int, anotherNumber num2: Int) -&gt; Int {
    <span class="keyword">return</span> num1 + num2
}
addTwoNumbers(oneNumber: <span class="number">10</span>, anotherNumber: <span class="number">20</span>) 

<span class="comment">// 忽略参数标签</span>
func addTwoNumbers(_ num1: Int, _ num2: Int) -&gt; Int {
    <span class="keyword">return</span> num1 + num2
}
addTwoNumbers(<span class="number">10</span>, <span class="number">20</span>)
</code></pre>
<hr>
<p>在函数体中通过给参数赋值可以为任意一个参数定义默认值。当默认值被定义后，调用这个函数时可以忽略这个参数。  </p>
<pre><code class="ObjC">func addTwoNumbers(num1: Int, num2: Int = <span class="number">1</span>) -&gt; Int {
    <span class="keyword">return</span> num1 + num2
}

addTwoNumbers(num1: <span class="number">10</span>)
addTwoNumbers(num1: <span class="number">10</span>, num2: <span class="number">20</span>)
</code></pre>
<p>如果一个函数有非默认值参数和默认值参数，一般来说，没有默认值的参数更加重要，因此，最好将不带默认值的参数放在参数列表的前面，可以使相同的函数在不同情况下调用时显得更为清晰。   </p>
<hr>
<p>通过在参数类型后加入 <code>...</code> 的方式来定义可变参数。一个可变参数可以接受零个或多个值。<br>可变参数的传入值在函数体中变为此类型的一个数组。<br>一个函数最多只能拥有一个可变参数。  </p>
<pre><code class="ObjC">func sum(_ numbers: Int...) -&gt; Int? {
    guard !numbers.isEmpty <span class="keyword">else</span> { <span class="keyword">return</span> <span class="literal">nil</span> }

    var result = <span class="number">0</span>
    <span class="keyword">for</span> number <span class="keyword">in</span> numbers {
        result += number
    }
    <span class="keyword">return</span> result
}

let a = sum()  <span class="comment">// nil</span>
let b = sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// 6</span>
</code></pre>
<hr>
<p>函数的参数默认是常量，试图在函数体中更改参数值将会导致编译错误。如果你想要修改函数的参数值，并且想要让这些修改后的参数值在函数调用结束后仍然保留，那么就应该把这个参数定义为输入输出参数。  </p>
<p>定义一个输入输出参数时，在参数类型前加 <code>inout</code> 关键字。  </p>
<p>只能传递变量给输入输出参数，不能传入常量或者字面量，因为这些量是不能被修改的。在调用的时候，在参数名前加 <code>&amp;</code> 符。  </p>
<pre><code class="ObjC">func swapTwoInts(a: <span class="keyword">inout</span> Int, b: <span class="keyword">inout</span> Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
var a = <span class="number">10</span>
var b = <span class="number">20</span>
swapTwoInts(a: &amp;a, b: &amp;b)
</code></pre>
<hr>
<p>在Swift中，每个函数都有其特定的函数类型 – 由函数的参数值类型和返回值类型组成的类型。  </p>
<pre><code class="ObjC">func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {
    <span class="keyword">return</span> a + b
}

func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int {
    <span class="keyword">return</span> a * b
}
</code></pre>
<p>上面这两个函数的类型为 <code>(Int, Int) -&gt; Int</code>。    </p>
<pre><code class="ObjC">func printHelloWorld() {
    print(<span class="string">"Hello World!"</span>)
}
</code></pre>
<p>上面这个函数的类型为 <code>() -&gt; Void</code>。</p>
<hr>
<p>可以把函数类型当做普通的类型一样来处理，比如可以把一个函数当做其他函数的参数，也能当做其他函数的返回值等等。    </p>
<pre><code class="ObjC">func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {
    <span class="keyword">return</span> a + b
}

func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int {
    <span class="keyword">return</span> a * b
}
func zeroResult(_ a: Int, _ b: Int) -&gt; Int {
    <span class="keyword">return</span> <span class="number">0</span>
}

<span class="comment">// 把函数类型当做普通类型</span>
var mathFunction: (Int, Int) -&gt; Int
mathFunction = addTwoInts
mathFunction(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment">// 8</span>
mathFunction = multiplyTwoInts
mathFunction(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment">// 15  </span>

<span class="comment">// 把函数类型当做另一个函数的参数类型</span>
func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {
    print(<span class="string">"Result: \(mathFunction(a, b))"</span>)
}
printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)  <span class="comment">// Result: 8</span>


<span class="comment">// 把函数类型当做返回值类型</span>
<span class="comment">// 下面这个函数根据传入不同的字符串来返回不同功能的函数</span>
func printMathResult(addOrMultipl: String) -&gt; (Int, Int) -&gt; Int {
    <span class="keyword">if</span> addOrMultipl == <span class="string">"add"</span> {
        <span class="keyword">return</span> addTwoInts
    } <span class="keyword">else</span> <span class="keyword">if</span> addOrMultipl == <span class="string">"multiply"</span> {
        <span class="keyword">return</span> multiplyTwoInts
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> zeroResult
    }
}

let add = printMathResult(addOrMultipl: <span class="string">"add"</span>)  <span class="comment">// 获得具有加法功能的函数</span>
let multiply = printMathResult(addOrMultipl: <span class="string">"multiply"</span>)  <span class="comment">// 获得具有乘法功能的函数</span>
let nothing = printMathResult(addOrMultipl: <span class="string">"nothing"</span>)  <span class="comment">// // 获得一个无论传什么参数，都返回0的函数</span>

add(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment">// 8</span>
multiply(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment">// 15</span>
nothing(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment">// 0</span>
</code></pre>
<hr>
<p>Swift中的函数允许嵌套使用。   </p>
<hr>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><hr>
<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与Objective-C中的 <code>Block</code> 以及其他编程语言中的匿名函数比较相似。   </p>
<hr>
<p>在Swift的代码中，闭包一般有如下三种形式：  </p>
<ul>
<li>全局函数是一个有名字但不会捕捉任何值的闭包。   </li>
<li>嵌套函数是一个有名字并可以捕获其外围函数域内值的闭包。   </li>
<li>闭包表达式是一个利用轻量级语法所写的并且可以捕获其上下文中变量和常量值的匿名闭包。  </li>
</ul>
<hr>
<p>闭包表达式的标准形式：  </p>
<pre><code class="ObjC">{ (parameters) -&gt; returnType <span class="keyword">in</span> 
    statement
}
</code></pre>
<p>闭包的函数体部分由关键字 <code>in</code> 引入，该关键字表示闭包的参数和返回值类型定义已经完成，闭包的函数体部分即将开始。   </p>
<hr>
<p>闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面通过对一个例子的几次迭代来展示闭包表达式的语法优化。  </p>
<p>Swift的标准库提供了一个 <code>sorted(by:)</code> 函数，该函数接收一个闭包作为其参数，对数组中的值进行排序，最终返回一个排序好的新数组，原数组不会被修改。   </p>
<p><code>sorted(by:)</code> 函数接收一个 <code>(Element, Element) -&gt; Bool</code> 类型的闭包，该闭包需要两个参数，并返回一个布尔值来表明第一个参数与第二个参数前后位置。    </p>
<pre><code class="ObjC">let names = [<span class="string">"Todd"</span>, <span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Barry"</span>, <span class="string">"Eric"</span>]

<span class="comment">// 提供一个符合sorted(by:)函数中闭包参数类型的普通函数</span>
func backward(s1: String, s2: String) -&gt; Bool {
    <span class="keyword">return</span> s1 &gt; s2
}
names.sorted(by: backward)

<span class="comment">// 利用标准的闭包表达式语法构建一个内联排序闭包</span>
var reversedNames01 = names.sorted(by: { (s1: String, s2: String) -&gt; Bool <span class="keyword">in</span>
    <span class="keyword">return</span> s1 &gt; s2
})

<span class="comment">// 根据上下文推断闭包表达式的参数和返回值类型</span>
<span class="comment">// 因为排序闭包函数是作为sorted(by:)函数的参数传入的，因此，Swift可以推断其参数和返回值的类型。</span>
<span class="comment">// sorted(by:)函数被一个字符串数组调用，因此其参数必定是 (String, String) -&gt; Bool 类型。</span>
let reversedNames02 = names.sorted(by: { s1 , s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 })

<span class="comment">// 单行表达式闭包可以通过省略 return 关键字来隐式返回单行表达式的结果</span>
let reversedNames03 = names.sorted(by: { s1 , s2 <span class="keyword">in</span> s1 &gt; s2 })

<span class="comment">// Swift为内联闭包提供了参数名称缩写功能，你可以直接通过 $0，$1，$2 等来顺序调用闭包的参数</span>
let reversedNames04 = names.sorted(by: { $<span class="number">0</span> &gt; $<span class="number">1</span> })

<span class="comment">// Swift的String类型定义了关于大于号（ &gt; ）的字符串实现，其作为一个函数接受两个String类型的参数并返回Bool类型的值。</span>
<span class="comment">// 而这正好与sorted(by:)函数的参数需要的函数类型相符合。</span>
let reversedNames05 = names.sorted(by: &gt;)

<span class="comment">// 如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。</span>
<span class="comment">// 尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</span>
let reversedNames06 = names.sorted() { $<span class="number">0</span> &gt; $<span class="number">1</span> }

<span class="comment">// 如果闭包表达式是函数的唯一参数，则当你使用尾随闭包时，还可以把 () 省略掉</span>
let reversedNames07 = names.sorted { $<span class="number">0</span> &gt; $<span class="number">1</span> }
</code></pre>
<hr>
<p>闭包可以在其被定义的上下文中捕获常量和变量，即使这些常量和变量的原作用域已经不存在了，闭包仍然可以在函数体内引用和修改这些值。    </p>
<p>在Swift中，可以捕获值的闭包的最简单的形式就是嵌套函数。嵌套函数可以捕获其外部函数的所有参数以及定义的常量和变量。  </p>
<pre><code class="ObjC">func makeIncrementer(amonut: Int) -&gt; () -&gt; Int {
    var totalNumber = <span class="number">0</span>
    func incrementer() -&gt; Int {
        totalNumber += amonut
        <span class="keyword">return</span> totalNumber
    }
    <span class="keyword">return</span> incrementer
}

let incrementByTen = makeIncrementer(amonut: <span class="number">10</span>)
incrementByTen()  <span class="comment">// 10</span>
incrementByTen()  <span class="comment">// 20</span>

let incrementBySeven = makeIncrementer(amonut: <span class="number">7</span>)
incrementBySeven()  <span class="comment">// 7</span>
incrementBySeven()  <span class="comment">// 14</span>
</code></pre>
<hr>
<p>函数和闭包都是引用类型。也就是说，无论你将函数或闭包赋值给一个常量还是变量，实际上你都是将常量或变量的值设置为对应函数或闭包的引用。   </p>
<pre><code class="ObjC">let incrementByTen = makeIncrementer(amonut: <span class="number">10</span>)
incrementByTen()  <span class="comment">// 10</span>
incrementByTen()  <span class="comment">// 20</span>

let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()  <span class="comment">// 30</span>
incrementByTen()  <span class="comment">// 40</span>
</code></pre>
<hr>
<p>当一个闭包作为参数传递到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当遇到这种情况时，可以在闭包参数名之前加上标注 <code>@escaping</code>，用来指明这个闭包是允许逃逸出这个函数的。  </p>
<pre><code class="ObjC">func doSomething(justPrintSomething: @escaping (String) -&gt; Void) -&gt; Void {
    print(<span class="string">"在主线程中做一部分事情，准备开启一个子线程做其余事情"</span>)
    DispatchQueue.global().async {
        print(<span class="string">"开启一个子线程做事情"</span>)
        DispatchQueue.main.async {
            print(<span class="string">"做完事情回到主线程"</span>)
            print(<span class="string">"执行闭包"</span>)
            justPrintSomething(<span class="string">"数据"</span>)
        }
    }
}

doSomething { (resultString: String) <span class="keyword">in</span>
    print(<span class="string">"传递出来的结果：\(resultString)"</span>)
}

<span class="comment">/*
在主线程中做一部分事情，准备开启一个子线程做其余事情
开启一个子线程做事情
做完事情回到主线程
执行闭包
传递出来的结果：数据
*/</span>
</code></pre>
<hr>
<p>将一个闭包标记为 <code>@escaping</code> 意味着你必须在闭包中显式地引用 <code>self</code>。  </p>
<hr>
<p><code>@autoclosure</code> 关键字用来修饰函数的闭包类型的参数，并且这种闭包的类型只能是 <code>() -&gt; T</code> 这种类型。在调用的时候，闭包可以用对应的表达式来代替，Swift会自动把对应的表达式转化成闭包样式。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。   </p>
<pre><code class="ObjC"><span class="comment">// 普通函数</span>
func logIfTrue(_ predicate: () -&gt; Bool) {
    <span class="keyword">if</span> predicate() {
        print(<span class="string">"log something"</span>)
    }
}
logIfTrue{ <span class="number">2</span> &gt; <span class="number">1</span> }

<span class="comment">// 用 @autoclosure 修饰闭包参数的函数</span>
func logIfTrue(_ predicate: @autoclosure () -&gt; Bool) {
    <span class="keyword">if</span> predicate() {
        print(<span class="string">"log something"</span>)
    }
}
logIfTrue( <span class="number">2</span> &gt; <span class="number">1</span> )  <span class="comment">// Swift会自动把 2 &gt; 1 这个表达式转化为 () -&gt; Bool 类型的闭包</span>
</code></pre>
<p>自动闭包 <code>@autoclosure</code> 最有用的地方就是延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些耗时操作或高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。Swift标准库中的 <code>??</code>，<code>&amp;&amp;</code>，<code>||</code> 等操作符的实现就用到了这个特性。   </p>
<hr>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><hr>
<p>枚举为一组相关的值定义了一个共同的类型，可以让你在代码中以类型安全的方式来使用这些值。   </p>
<hr>
<p>在Swift中，枚举是一等类型。    </p>
<p>Swift中的枚举非常灵活，不必给每一个枚举成员提供一个值。如果想要给枚举成员提供一个值（原始值），则该值的类型可以是整型、浮点型、字符型和字符串型。   </p>
<p>Swift中的枚举采用了很多只被类所支持的特性，比如计算属性，用来提供枚举值的附加信息；构造函数，用来提供一个初始值；实例方法，用来提供和枚举值相关联的功能；还可以遵守协议来提供标准的功能；还可以在原始实现的基础上扩展枚举的功能。   </p>
<hr>
<pre><code class="ObjC"><span class="keyword">enum</span> Direction {
    <span class="keyword">case</span> north
    <span class="keyword">case</span> south
    <span class="keyword">case</span> east
    <span class="keyword">case</span> west
}

var direction = Direction.north
direction = . east
</code></pre>
<p><code>Direction</code> 枚举类型中定义的值 <code>north</code>，<code>south</code>，<code>east</code>，<code>west</code> 是这个枚举的成员值。  </p>
<p>与C和Objective-C不同的是，Swift中的枚举成员在被创建的时候没有默认的整型值，这些枚举的成员值本身就是完备的值，这些值的类型是已经明确定义好的 <code>Direction</code> 类型。   </p>
<p>每个枚举定义了一个全新的类型，就像是Swift中的其他类型一样。枚举的名字应该以大写字母开头，且最好是单数形式。  </p>
<hr>
<p>使用 <code>switch</code> 语句来匹配单个枚举值。<br>在判断一个枚举类值时，<code>switch</code> 语句必须穷举所有情况。强制穷举能确保枚举成员不会被意外遗漏。  </p>
<pre><code class="ObjC">var direction = Direction.north

<span class="keyword">switch</span> direction {
<span class="keyword">case</span> .north:
    print(<span class="string">"North"</span>)
<span class="keyword">case</span> .south:
    print(<span class="string">"South"</span>)
<span class="keyword">case</span> .east:
    print(<span class="string">"East"</span>)
<span class="keyword">case</span> .west:
    print(<span class="string">"West"</span>)
}
</code></pre>
<hr>
<p>枚举成员可以指定任意类型的关联值存储在枚举成员中，且同一个枚举中不同的枚举成员可以有不同类型的关联值。      </p>
<p>枚举关联值的主要作用是让你在存储成员值的同时还能存储额外的自定义信息，并且当你在代码中使用该枚举成员时，还可以修改这个关联值。</p>
<pre><code class="ObjC"><span class="comment">// 某个系统的设置信息</span>
<span class="keyword">enum</span> Setting {
    <span class="keyword">case</span> string(String)
    <span class="keyword">case</span> <span class="keyword">int</span>(Int)
    <span class="keyword">case</span> <span class="keyword">bool</span>(Bool)
}  

<span class="comment">// 商品的两种不同类型的条形码</span>
<span class="keyword">enum</span> Barcode { 
    <span class="keyword">case</span> upc(Int, Int, Int, Int) 
    <span class="keyword">case</span> qrCode(String)
}

var productBarcode = Barcode.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)
productBarcode = .qrCode(<span class="string">"ABCDEFGHIJKLMNOP"</span>)

<span class="keyword">switch</span> productBarcode { 
<span class="keyword">case</span> let .upc(numberSystem, manufacturer, product, check): 
    print(<span class="string">"UPC: \(numberSystem), \(manufacturer), \(product), \(check)."</span>)
<span class="keyword">case</span> .qrCode(let productCode):
    print(<span class="string">"QR code: \(productCode)."</span>) 
}
</code></pre>
<hr>
<p>枚举成员可以被默认值（原始值）预填充，这些原始值的类型必须相同。  </p>
<pre><code class="ObjC"><span class="keyword">enum</span> AS<span class="built_in">CIIControlCharacter</span>: Character { 
    <span class="keyword">case</span> tab = <span class="string">"\t"</span> 
    <span class="keyword">case</span> lineFeed = <span class="string">"\n"</span> 
    <span class="keyword">case</span> carriageReturn = <span class="string">"\r"</span> 
}
</code></pre>
<p>原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，如上面三个字符类型的ASCII码。对于一个特定的枚举成员，它的原始值始终不变。关联值是在创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值是可以变化的。  </p>
<hr>
<p>原始值的隐式赋值：如果枚举类型在定义的时候被声明为整型和字符串类型时，不需要显示地为每一个枚举成员设置原始值，Swift会自动赋值。  </p>
<pre><code class="ObjC"><span class="comment">// 不给成员值赋原始值（整型）</span>
<span class="keyword">enum</span> Month: Int {
    <span class="keyword">case</span> January, February, March, April, May, June,
         July, August, September, October, November, December
}
let a: Month = .February
a.rawValue  <span class="comment">// 1</span>

<span class="comment">// 只给第一个成员值赋原始值（整型）</span>
<span class="keyword">enum</span> Month: Int {
    <span class="keyword">case</span> January = <span class="number">1</span>, February, March, April, May, June,
         July, August, September, October, November, December
}
let a: Month = .February
a.rawValue  <span class="comment">// 2</span>

<span class="comment">// 不给成员值赋原始值（字符串）</span>
<span class="comment">// 字符串类型的隐式原始值为该枚举成员的名称</span>
<span class="keyword">enum</span> Month: String {
    <span class="keyword">case</span> January, February, March, April, May, June,
         July, August, September, October, November, December
}
let a: Month = .February
a.rawValue  <span class="comment">// February</span>
</code></pre>
<hr>
<p>使用原始值初始化枚举实例：如果在定义枚举类型的时候显示或者隐式地使用了原始值，那么Swift会自动为该枚举类型生成一个初始化方法，这个方法接受一个 <code>rawValue</code> 的参数，返回一个可选类型的枚举值。  </p>
<pre><code class="ObjC"><span class="keyword">enum</span> Month: Int {
    <span class="keyword">case</span> January, February, March, April, May, June,
         July, August, September, October, November, December
}
let a: Month? = Month(rawValue: <span class="number">3</span>)  <span class="comment">// Optional(Month.April)</span>
</code></pre>
<hr>
<p>递归枚举是一种枚举类型，它有一个或多个成员使用该枚举类型本身的实例作为关联值。  </p>
<p>在枚举成员前加上 <code>indirect</code> 来表示该成员可递归。  </p>
<pre><code class="ObjC"><span class="comment">// 该枚举类型存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。</span>
<span class="keyword">enum</span> ArithmeticExpression { 
    <span class="keyword">case</span> number(Int) 
    indirect <span class="keyword">case</span> addition(ArithmeticExpression, ArithmeticExpression) 
    indirect <span class="keyword">case</span> multiplication(ArithmeticExpression, ArithmeticExpression) 
}

<span class="comment">// 表达式：(5 + 4) * 2</span>
let five = ArithmeticExpression.number(<span class="number">5</span>) 
let four = ArithmeticExpression.number(<span class="number">4</span>) 
let two = ArithmeticExpression.number(<span class="number">2</span>)
let sum = ArithmeticExpression.addition(five, four) 
let result = ArithmeticExpression.multiplication(sum, two) 

<span class="comment">// 要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。</span>
func evaluate(_ expression: ArithmeticExpression) -&gt; Int { 
    <span class="keyword">switch</span> expression { 
    <span class="keyword">case</span> let .number(value):
        <span class="keyword">return</span> value 
    <span class="keyword">case</span> let .addition(left, right):
        <span class="keyword">return</span> evaluate(left) + evaluate(right) 
    <span class="keyword">case</span> let .multiplication(left, right):
        <span class="keyword">return</span> evaluate(left) * evaluate(right) 
    }
}

evaluate(result)  <span class="comment">// 18</span>
</code></pre>
<hr>
<h3 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h3><hr>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/18/005-Hexo-GitHub/" rel="next" title="HEXO+GitHub搭建个人博客">
                <i class="fa fa-chevron-left"></i> HEXO+GitHub搭建个人博客
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/17/007-Swift-Array/" rel="prev" title="Swift Array">
                Swift Array <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Todd Cheng" />
          <p class="site-author-name" itemprop="name">Todd Cheng</p>
          <p class="site-description motion-element" itemprop="description">古佛中的逗逼佛</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Todd2010" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/todd2010" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础部分"><span class="nav-number">1.</span> <span class="nav-text">基础部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本运算符"><span class="nav-number">2.</span> <span class="nav-text">基本运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串和字符"><span class="nav-number">3.</span> <span class="nav-text">字符串和字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合类型"><span class="nav-number">4.</span> <span class="nav-text">集合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制流"><span class="nav-number">5.</span> <span class="nav-text">控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">7.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举"><span class="nav-number">8.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类和结构体"><span class="nav-number">9.</span> <span class="nav-text">类和结构体</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Todd Cheng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
