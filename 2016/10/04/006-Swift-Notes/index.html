<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="article">
<meta property="og:title" content="《The Swift Programming Language》读书摘要">
<meta property="og:url" content="http://todd2010.github.io/2016/10/04/006-Swift-Notes/index.html">
<meta property="og:site_name" content="Buddha's Temple">
<meta property="og:description">
<meta property="og:image" content="http://7xth9g.com2.z0.glb.clouddn.com/Swift_Notes_001.png">
<meta property="og:updated_time" content="2016-11-22T13:57:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《The Swift Programming Language》读书摘要">
<meta name="twitter:description">
<meta name="twitter:image" content="http://7xth9g.com2.z0.glb.clouddn.com/Swift_Notes_001.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 《The Swift Programming Language》读书摘要 | Buddha's Temple </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=56164015";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Buddha's Temple</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                《The Swift Programming Language》读书摘要
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-04T10:07:00+08:00" content="2016-10-04">
              2016-10-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://7xth9g.com2.z0.glb.clouddn.com/Swift_Notes_001.png" alt="Swift_Notes_001.png">   </p>
<a id="more"></a>    
<hr>
<h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><hr>
<p>Swift包含了C和Objecitve-C中所有的基础数据类型，<code>Int</code> 表示整型值；<code>Double</code> 和 <code>Float</code> 表示浮点型值；<code>Bool</code> 表示布尔型值；<code>String</code> 表示字符串型值；<code>Character</code> 表示字符型值。   </p>
<hr>
<p>Swift提供了三个的基本的集合类型：<code>Array</code>、<code>Dictionary</code>、<code>Set</code>。   </p>
<hr>
<p>在Swift中，如果你要处理的值不需要改变，那么使用常量可以让你的代码更加安全并且能更清晰的表达你的意图。   </p>
<hr>
<p>Swift增加了Objective-C中没有的高阶数据类型 —— 元祖（Tuple）。   </p>
<hr>
<p>Swift增加了Objective-C中没有的可选类型（Optional），用于处理值缺失的情况。   </p>
<hr>
<p>Swift是一门类型安全的语言，这意味着Swift可以让你清楚的知道值的类型。   </p>
<hr>
<p>常量和变量必须要在使用前声明，用 <code>let</code> 来声明常量，用 <code>var</code> 来声明变量。  </p>
<pre><code class="ObjC">let maximumNumberOfLoginAttempts = <span class="number">10</span>
var currentLoginAttempt = <span class="number">0</span>
</code></pre>
<hr>
<p>可以在一行中声明多个常量或变量，用逗号隔开。  </p>
<pre><code class="ObjC">var a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0.0</span>  <span class="comment">// a和b均为Int类型  c为Double类型</span>
</code></pre>
<hr>
<p>当你声明常量或变量的时候可以加上类型标注（type annotation），用来说明常量或变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加一个冒号和一个空格，然后再加上类型名称。  </p>
<pre><code class="ObjC">var a, b: Int, c: Double  <span class="comment">// a和b均为Int类型  c为Double类型</span>
</code></pre>
<p>一般来说，很少需要写类型标注。如果在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或变量的类型。   </p>
<hr>
<p>你可以用 <code>print(_:separator:terminator:)</code> 函数来输出常量或变量的值。<br><code>print(_:separator:terminator:)</code> 函数是一个用来输出一个或多个值到适当输出区的全局函数，在Xcode中，该函数将会把内容输出到控制台面板上。   </p>
<pre><code class="ObjC"><span class="comment">// print(_:separator:terminator:) 函数在标准库中的定义</span>
public func print(_ items: Any..., separator: String = <span class="keyword">default</span>, terminator: String = <span class="keyword">default</span>)

<span class="comment">/**
Parameters:
  - items: Zero or more items to print.
  - separator: A string to print between each item. The default is a single space (" ").
  - terminator: The string to print after all items have been printed. The default is a newline ("\n").
*/</span>
</code></pre>
<hr>
<p>Swift采用字符串插值（string interpolation）的方式把常量名或变量名当做占位符插入到字符串中，在运行时用当前常量或变量的值替换这些占位符。  </p>
<pre><code class="ObjC">let name = <span class="string">"Todd Cheng"</span>
let age = <span class="number">18</span>
print(<span class="string">"my name is \(name), my age is \(age)"</span>)
</code></pre>
<hr>
<p>Swift支持多行注释的嵌套。  </p>
<hr>
<p>你可以访问不同整数类型的 <code>max</code> 和 <code>min</code> 属性来获取对应整数类型的最大值和最小值。   </p>
<pre><code class="ObjC">let a = <span class="built_in">UInt8</span>.max  <span class="comment">// a的值为255，且a的类型为UInt8</span>
let b = <span class="built_in">UInt8</span>.min  <span class="comment">// b的值为0，且b的类型为UInt8</span>
</code></pre>
<hr>
<p>Swift提供了一个特殊的整数类型 <code>Int</code>，长度与当前平台的原生字长相同。   </p>
<ul>
<li>在32位平台设备上，<code>Int</code> 就是 <code>Int32</code>。  </li>
<li>在64位平台设备上，<code>Int</code> 就是 <code>Int64</code>。    </li>
</ul>
<p>Swift还提供了一个特殊的无符号整数类型 <code>UInt</code>，长度与当前平台的原生字长相同。  </p>
<ul>
<li>在32位平台设备上，<code>UInt</code> 就是 <code>UInt32</code>。  </li>
<li>在64位平台设备上，<code>UInt</code> 就是 <code>UInt64</code>。  </li>
</ul>
<p>尽量不要使用 <code>UInt</code> 或其他整数类型（如 <code>Int8</code>，<code>Int16</code>，<code>Int32</code>，<code>Int64</code>，<code>UInt8</code>，<code>UInt16</code>，<code>UInt32</code>，<code>UInt64</code> 等），最好使用 <code>Int</code>，即使你要存储的整数常量或者变量已知是非负的。统一使用 <code>Int</code> 可以提高代码的可复用性，避免不同类型之间的转换，并且可以匹配整数类字面量的类型推断。</p>
<hr>
<p>Swift提供了两种浮点数类型：  </p>
<ul>
<li><code>Double</code> 表示64位浮点数。可以精确到小数点后15位。   </li>
<li><code>Float</code> 表示32位浮点数。可以精确到小数点后6位。  </li>
</ul>
<pre><code class="ObjC">let a = <span class="number">1.01234567890123456789</span>
let b = <span class="number">1.0123456789012345</span>
let c = <span class="number">1.0123456789012346</span>

a == b  <span class="comment">// false</span>
a == c  <span class="comment">// true</span>
</code></pre>
<pre><code class="ObjC">let a: Float = <span class="number">1.12345678</span>
let b: Float = <span class="number">1.1234567</span>
let c: Float = <span class="number">1.1234568</span>

a == b  <span class="comment">// false</span>
a == c  <span class="comment">// true</span>
</code></pre>
<hr>
<p>Swift是一门类型安全的语言。类型安全的语言可以让你清楚的知道代码要处理的值的类型。比如代码需要一个 <code>String</code>，你绝不可能一不留神赋值一个 <code>Int</code>。   </p>
<hr>
<p>当你在声明常量或者变量的时候赋给它们一个字面量（literal value）即可触发类型推断。  </p>
<hr>
<p>整数字面量可以被写成：  </p>
<ul>
<li>十进制数，没有前缀。  </li>
<li>二进制数，前缀是 <code>0b</code>。  </li>
<li>八进制数，前缀是 <code>0o</code>。  </li>
<li>十六进制数，前缀是 <code>0x</code>。  </li>
</ul>
<hr>
<p>浮点数可以有一个可选的指数（exponent），用大写 <code>E</code> 或者小写 <code>e</code> 来表示。比如 <code>1.25E2</code> 就是 <code>125.0</code>，<code>1.25e-2</code> 就是 <code>0.0125</code>。  </p>
<hr>
<p>整数和浮点数可以添加下划线 <code>_</code> 来增强可读性，并且不会影响字面量的值。  </p>
<pre><code class="ObjC">let a = <span class="number">1000</span>_000<span class="number">.000</span>_000_1
let b = <span class="number">10000</span>_0000
</code></pre>
<hr>
<p>类型别名就是给现有的类型定义一个新名字，可以使用 <code>typealias</code> 关键字来定义类型别名。  </p>
<hr>
<p>如果你在需要使用 <code>Bool</code> 类型的地方使用了非 <code>Bool</code> 值，Swift的类型安全机制会报错。比如：  </p>
<pre><code class="ObjC">let i = <span class="number">1</span>
<span class="keyword">if</span> i { }  <span class="comment">// 这行代码不会通过编译，会报错   </span>
<span class="keyword">if</span> i == <span class="number">1</span> {}  <span class="comment">// 正确写法</span>
</code></pre>
<p>这种方式可以避免一些错误并保证这块代码的意图总是清晰的。  </p>
<hr>
<p>元组把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。  </p>
<pre><code class="ObjC">let http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
<span class="comment">// http404Error的类型为 (Int, String)</span>
</code></pre>
<p>通过下标来访问元组中的单个元素，下标从0开始。    </p>
<pre><code class="ObjC">let http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
http404Error<span class="number">.0</span>
http404Error<span class="number">.1</span>
</code></pre>
<hr>
<p>可以在定义元组的时候给每一个元素命名。   </p>
<pre><code class="ObjC">let http404Error = (code: <span class="number">404</span>, description: <span class="string">"Not Found"</span>)
http404Error.code
http404Error.description
</code></pre>
<hr>
<p>你可以将一个元组的内容分解成单独的常量或变量，然后再分别使用它们。  </p>
<pre><code class="ObjC">let (statusCode, statusMessage) = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
statusCode
statusMessage
</code></pre>
<p>如果你只需要一部分元组值，分解的时候可以把忽略的部分用下划线 <code>_</code> 标记。  </p>
<pre><code class="ObjC">let (_, justStatusMessage) = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
justStatusMessage
</code></pre>
<hr>
<p>使用可选类型来处理值可能缺失的情况。可选类型表示要么有值，为 <code>x</code>；要么没有值，为 <code>nil</code>。</p>
<hr>
<p>C和Objective-C中并没有可选类型这个概念。Objective-C中的 <code>nil</code> 只能用在对象身上，对于结构体、基本的C类型或者枚举类型都不起作用。对于这些类型，Objective-C一般会返回一个特殊值（比如 <code>NSNotFound</code> ）来暗示值缺失。这种办法是基于调用者知道并记得对特殊值判断的前提下的。然而，Swift的可选类型可以让你暗示任意值的缺失，并不需要一个特殊值。   </p>
<hr>
<p>如果你声明一个可选常量或者变量但是没有赋值，它会自动被设置为 <code>nil</code>。  </p>
<hr>
<p>Swift中的 <code>nil</code> 和Objective-C中 <code>nil</code> 并不一样。在Objective-C中，<code>nil</code> 是一个指向不存在对象的指针；在Swift中，<code>nil</code> 不是指针，它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型。  </p>
<hr>
<p>可以使用 <code>if</code> 语句让一个可选类型的常量或变量与 <code>nil</code> 比较是否相等来判断该可选常量或变量是否包含值。<br>如果可选类型有值，它将不等于 <code>nil</code>。并且当确定了一个可选类型确实包含值之后，可以在可选类型的常量或变量名字后面加一个感叹号 <code>!</code> 来获取其中的值，这被称为可选类型的强制解包。   </p>
<pre><code class="ObjC">let a = Int(<span class="string">"123"</span>)
<span class="keyword">if</span> a != <span class="literal">nil</span> {
    print(a!)
}
</code></pre>
<p>使用 <code>!</code> 来获取一个不存在的可选类型会导致运行时错误。因此，在使用 <code>!</code> 来强制解包之前，一定要确定可选类型包含一个非 <code>nil</code> 的值。  </p>
<hr>
<p>使用可选绑定来判断可选类型是否包含值，如果包含，就把值赋给一个临时的常量或变量。可选绑定可以用在 <code>if</code> 和 <code>while</code> 语句中。  </p>
<pre><code class="ObjC"><span class="keyword">if</span> let a = Int(<span class="string">"123"</span>) {
    print(a)
}
</code></pre>
<hr>
<p>你可以在一个 <code>if</code> 语句中包含多个可选绑定或多个布尔条件，使用逗号分开就行，只要有任意一个可选绑定的值为 <code>nil</code>，或者任意一个布尔条件的值为 <code>false</code>，则整个 <code>if</code> 语句的条件判断为 false。   </p>
<hr>
<p>在 <code>if</code> 条件语句中使用常量或变量来创建一个可选绑定，仅在 <code>if</code> 语句的句中才能获取到该常量或变量的值。<br>相反，在 <code>guard</code> 语句中使用常量或变量来创建一个可选绑定，仅在 <code>guard</code> 语句外且在语句后才能获取到该常量或变量的值。  </p>
<hr>
<p>有时候在代码中，在可选类型被第一次赋值之后，可以确定该可选类型总会有值，在这种情况下，每次都要判断和解包可选值是非常低效的。这时候可以把该可选类型声明为隐式解包可选类型（implicitly unwrapped optional），把普通可选类型后的问号（如 <code>String?</code>）改为感叹号（如 <code>String!</code>）来声明一个隐式解包可选类型。   </p>
<p>一个隐式解包可选类型其本质还是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次解包来获得可选值。  </p>
<pre><code class="ObjC">let optionalString: String? = <span class="string">"Optional String"</span>
print(optional!)

let implicitlyOptionalString: String! = <span class="string">"Implicitly Optional String"</span>
print(implicitlyOptionalString)
</code></pre>
<p>如果在隐式解包可选类型没有值的时候尝试取值，仍会触发运行时错误。这和在没有值的普通可选类型后面加感叹号是一样的。</p>
<hr>
<p>你仍然可以把隐式解包可选类型当做普通的可选类型，用 <code>if</code> 来判断是否有值，用可选绑定来解包可选值。   </p>
<hr>
<p>相对于可选类型用值的存在与缺失来表达一个函数是否包含满足条件的值，错误处理可以推断出函数调用失败的原因，并传播至程序的其他地方。    </p>
<hr>
<p>一个函数可以通过在声明中添加 <code>throws</code> 关键字来表明函数有可能会抛出错误消息。<br>当一个函数能抛出错误消息时，在调用该函数的时候应该前置 <code>try</code> 关键字来捕获错误消息。  </p>
<pre><code class="ObjC">func canThrowAnError() throws {
    <span class="comment">// 这个函数有可能抛出错误</span>
}

<span class="keyword">do</span> {
    try canThrowAnError()
    aFunc()
} catch xxxError.oneError {
    oneErrorHandle()
} catch xxxError.twoError {
    twoErrorHandle()
}
</code></pre>
<p>一个 <code>do</code> 语句创建了一个新的包含作用域，使得错误能被传播到一个或多个 <code>catch</code> 从句中。  </p>
<hr>
<p>可选类型能够让你判断值是否存在，你可以在代码中优雅的处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，代码就没办法继续执行，这时，你可以在代码中触发一个断言来结束代码运行并通过调试来找到无法继续执行下去的原因。<br>你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。断言会在运行时判断一个逻辑条件是否为true。如果条件判断为true，代码会继续进行；如果条件判断为false，应用程序将被终止。在调试环境下，你可以从Xcode中清楚的看到不合法的状态发生在哪里并以此来检查断言被触发时代码的状态。</p>
<hr>
<p>你可以使用全局函数 <code>assert(_:_:file:line:)</code> 来实现一个断言。  </p>
<pre><code class="ObjC"><span class="comment">// assert(_:_:file:line:) 函数在标准库中的定义</span>

<span class="comment">/// To check for invalid usage in Release builds, </span>
<span class="comment">/// see `precondition(_:_:file:line:)`.</span>

<span class="comment">/// * In playgrounds and `-Onone` builds (the default for Xcode's Debug</span>
<span class="comment">///   configuration): If `condition` evaluates to `false`, stop program</span>
<span class="comment">///   execution in a debuggable state after printing `message`.</span>

<span class="comment">/// * In `-O` builds (the default for Xcode's Release configuration), </span>
<span class="comment">/// `condition` is not evaluated, and there are no effects.</span>

<span class="comment">/// - Parameters:</span>
<span class="comment">///   - condition: The condition to test. `condition` is only evaluated in</span>
<span class="comment">///     playgrounds and `-Onone` builds.</span>
<span class="comment">///   - message: A string to print if `condition` is evaluated to `false`. The</span>
<span class="comment">///     default is an empty string.</span>
<span class="comment">///   - file: The file name to print with `message` if the assertion fails. The</span>
<span class="comment">///     default is the file where `assert(_:_:file:line:)` is called.</span>
<span class="comment">///   - line: The line number to print along with `message` if the assertion</span>
<span class="comment">///     fails. The default is the line number where `assert(_:_:file:line:)`</span>
<span class="comment">///     is called.</span>

public func assert(_ condition: @autoclosure () -&gt; Bool, 
                     _ message: @autoclosure () -&gt; String = <span class="keyword">default</span>, 
                          file: StaticString = <span class="meta">#file, </span>
                          line: <span class="built_in">UInt</span> = <span class="meta">#line)  </span>

let age = <span class="number">-3</span>
assert(age &gt; <span class="number">0</span>, <span class="string">"A person's age cannot be less than zero"</span>)  <span class="comment">// 不满足条件，断言被触发，应用终止。</span>
</code></pre>
<p>当代码使用优化编译的时候，断言将被禁用。例如在Xcode中，使用默认的 Target Release 配置选项来编译时，断言会被禁用。  </p>
<hr>
<h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><hr>
<p>Swift支持大部分的C语言运算符，且改进了许多特性来减少常规编码错误。如：  </p>
<ul>
<li>赋值符 <code>=</code> 不返回值。为了防止把想要判断相等运算符 <code>==</code> 的地方写成赋值运算符导致的错误。   </li>
<li>算术运算符（<code>+, -, *, /, %</code> 等）不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。（Swift允许你使用溢出运算符 <code>&amp;</code> 来实现溢出）  </li>
</ul>
<hr>
<p>运算符分为一元、二元和三元运算符：  </p>
<ul>
<li>一元运算符操作一个操作数。如 <code>-a</code>，<code>+a</code>，<code>!a</code>，<code>a!</code> 等。   </li>
<li>二元运算符操作两个操作数。如 <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>=</code>等。  </li>
<li>三元运算符操作三个操作数。和C语言一样，Swift只有一个三元运算符，就是三目运算符（<code>a ? b : c</code>）。   </li>
</ul>
<hr>
<p>与C语言和Objective-C不同，Swift的赋值操作并不返回任何值。所以以下代码是错误的：  </p>
<pre><code class="ObjC"><span class="keyword">if</span> x = y { }  <span class="comment">// 错误代码，因为 x = y 并不返回任何值，而 if 后面需要一个逻辑布尔值。</span>
</code></pre>
<p>这个特性使你无法把 <code>==</code> 错写成 <code>=</code>。  </p>
<hr>
<p>与C语言和Objective-C不同的是，Swift默认情况下不允许在数值运算中出现溢出情况。但是你可以使用Swift的溢出运算符来实现溢出运算（如 <code>a &amp;+ b</code>）。   </p>
<hr>
<p><code>a % b</code>，当 <code>b</code> 为负数时，<code>b</code> 的符号会被忽略。也就是说，<code>a % b</code> 与 <code>a % -b</code> 的结果是一样的。    </p>
<pre><code class="ObjC"><span class="number">9</span> % <span class="number">4</span>    <span class="comment">// 1</span>
<span class="number">9</span> % <span class="number">-4</span>   <span class="comment">// 1</span>

<span class="number">-9</span> % <span class="number">4</span>    <span class="comment">// -1</span>
<span class="number">-9</span> % <span class="number">-4</span>   <span class="comment">// -1</span>
</code></pre>
<hr>
<p>复合赋值运算符（如 <code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code> 等）没有返回值。类似 <code>let b = a += 2</code> 这样的代码是错误的。   </p>
<hr>
<p>Swift提供了恒等 <code>===</code> 和不恒等 <code>!==</code> 这两个比较符来判断两个常量或变量是否引用了同一个对象实例。  </p>
<hr>
<p>当元组中的值可以比较时，你可以使用比较运算符来比较他们的大小。比如，<code>Int</code> 和 <code>Sting</code> 类型的值可以比较大小，所以类型为 <code>(Int, String)</code> 的元组也可以比较大小。相反，<code>Bool</code> 类型的值无法比较大小（但可以比较是否相等），也意味着存在 <code>Bool</code> 类型的元组也就无法比较大小（但可以比较是否相等）。<br>比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组就称之为相等。   </p>
<hr>
<p>Swift的标准库中只支持7个元素以内的元组来比较大小，如果元组中元素超过7个，则需要自己实现比较操作。  </p>
<hr>
<p>三目运算符（ <code>a ? b : c</code> ）提供了高效率且便捷的方式来表达二选一的概念。需要注意的是，过度使用三目运算符会使简洁的代码变得难懂，我们应该避免在一个语句中使用多个三目运算符。   </p>
<hr>
<p>空和运算符 <code>a ?? b</code> 将对可选类型 <code>a</code> 进行空判断，如果 <code>a</code> 包含值就进行解包，否则就返回一个默认值 <code>b</code>。<br><code>a</code> 必须是可选类型，默认值 <code>b</code> 的类型必须要和 <code>a</code> 存储的值的类型保持一致。   </p>
<hr>
<p>空和运算符 <code>a ?? b</code> 其实是对三目运算符 <code>a != nil ? a! : b</code> 的简洁写法。   </p>
<hr>
<p>Swift提供了两个方便表达一个区间的运算符：闭区间运算符 <code>a...b</code> 以及 半开区间运算符 <code>a..&lt;b</code>。     </p>
<p>半开区间运算符的实用性在于当你使用一个从0开始的列表时，可以非常方便的从0遍历到列表的长度。  </p>
<hr>
<p>逻辑运算符的操作对象是逻辑布尔值。<br>Swift支持C语言的三个标准逻辑运算符：  </p>
<ul>
<li>逻辑非 <code>!a</code>。  </li>
<li>逻辑与 <code>a &amp;&amp; b</code>。  </li>
<li>逻辑或 <code>a || b</code>。  </li>
</ul>
<p>逻辑与和逻辑或运算符是支持短路计算的。  </p>
<hr>
<h3 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h3><hr>
<p><code>String</code> 类型是一种快速、现代化的字符串实现。每一个字符串都是由编码无关的 <code>Unicode</code> 字符组成，并支持访问字符的多种 <code>Unicode</code> 表示形式。   </p>
<hr>
<p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的 <code>String</code> 实例。   </p>
<pre><code class="ObjC">var emptyString1 = <span class="string">""</span>          <span class="comment">// 空字符串字面量</span>
var emptyString2 = String()    <span class="comment">// 初始化方法</span>
<span class="comment">// emptyString1 与 emptyString2 均为空字符串并相等</span>
</code></pre>
<p>可以通过 <code>String</code> 中 <code>isEmpty</code> 属性来判断字符串是否为空：   </p>
<pre><code class="ObjC"><span class="keyword">if</span> emptyString1.isEmpty { }
</code></pre>
<hr>
<p>Swfit中的 <code>String</code> 类型是值类型。也就是说，如果你创建了一个字符串，那么当其为其他常量或变量进行赋值操作，或在函数中传递时，会进行值拷贝。   </p>
<p>Swift编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着把字符串作为值类型的同时可以获得极高的性能。  </p>
<hr>
<p>可以通过 <code>for-in</code> 循环遍历字符串的 <code>characters</code> 属性来获取每一个字符的值。   </p>
<pre><code class="ObjC"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Todd"</span> { 
    print(character) 
}
</code></pre>
<hr>
<p>字符串可以通过传递一个 <code>Character</code> 数组来进行初始化：   </p>
<pre><code class="ObjC">let catCharacters: [Character] = [<span class="string">"C"</span>, <span class="string">"A"</span>, <span class="string">"T"</span>]
let catString = String(catCharacters)
</code></pre>
<hr>
<p>字符串可以通过加法运算符 <code>+</code> 来把两个字符串连接在一起：  </p>
<pre><code class="ObjC">let string1 = <span class="string">"Hello "</span>
let string2 = <span class="string">"Todd!"</span>
let string3 = string1 + string2
</code></pre>
<p>也可以通过加法赋值运算符 <code>+=</code> 来把一个字符串添加到一个已经存在的字符串变量上：   </p>
<pre><code class="ObjC">var string4 = <span class="string">"Welcome "</span>
string4 += <span class="string">"Todd!"</span>
</code></pre>
<p>还可以通过 <code>append()</code> 函数将一个字符附加到一个字符串变量的尾部：   </p>
<pre><code class="ObjC">var string5 = <span class="string">"Chen"</span>
var character: Character = <span class="string">"g"</span>  
string5.append(character)

<span class="comment">// 在Swift的标准库中，String 的 append(_:) 函数有两种定义。</span>
public mutating func append(_ c: Character)
public mutating func append(_ other: String)
</code></pre>
<hr>
<p><code>Unicode</code> 是一个国际标准，用于文本的编码和表示。它使你能够用标准的格式来表示来自任意语言几乎所有的字符。Swift的 <code>String</code> 和 <code>Character</code> 类型是完全兼容 <code>Unicode</code> 标准的。   </p>
<hr>
<p>字符串字面量的特殊字符：  </p>
<ul>
<li>转义字符：<code>\0</code>（空字符），<code>\\</code>（反斜线），<code>\t</code>（水平制表符），<code>\n</code>（换行符），<code>\r</code>（回车符），<code>\&quot;</code>（双引号），<code>\&#39;</code>（单引号）。   </li>
<li><code>Unicode</code> 标量：写成 <code>\u{n}</code>（<code>u</code> 为小写），其中 <code>n</code> 为任意一到八位十六进制数且可用的 <code>Unicode</code> 标量。   </li>
</ul>
<hr>
<p>每一个Swift的 <code>Character</code> 类型都代表一个可扩展的字符群集。一个可扩展的字符群集是一个或多个 <code>Unicode</code> 标量的有序排列。<br>比如，字符 <code>é</code> 可以用单一的 <code>Unicode</code> 标量 <code>\u{00E9}</code> 来表示。也可以用一个标准的字符 <code>e</code>  <code>\u{0065}</code> 加上一个急促重音 <code>\u{0301}</code> 来表示。    </p>
<hr>
<p>可以通过访问字符串的 <code>characters</code> 属性的 <code>count</code> 属性来获取字符串中 <code>Character</code> 值的数量。  </p>
<hr>
<p>可扩展的字符群集可以由一个或多个 <code>Unicode</code> 标量组合而成，这也就意味着相同字符的不同表示方式可能需要不同数量的内存空间来存储，所以Swift中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取到可扩展字符群集范围的时候，是无法计算出字符串中字符数量的。当你在处理一个字符串的时候，需要注意到 <code>characters</code> 属性的访问必须要遍历字符串中全部的 <code>Unicode</code> 标量才能确定字符的数量。   </p>
<hr>
<p>每一个 <code>String</code> 值都有一个关联的索引类型（<code>String.Index</code>），它对应着字符串中每一个 <code>Character</code> 的位置。<br>字符的不同表示方式可能会占用不同数量的内存空间，所以要知道 <code>Character</code> 的具体位置，就必须从 <code>String</code> 的开头遍历每一个 <code>Unicode</code> 标量直到结尾。因此，Swift的字符串不能用整型做索引。   </p>
<hr>
<p>使用 <code>startIndex</code> 属性可以获取一个 <code>String</code> 的第一个 <code>Character</code> 索引。<br>使用 <code>endIndex</code> 属性可以获取一个 <code>String</code> 的最后一个 <code>Character</code> 的后一个位置的索引。  </p>
<p><code>endIndex</code> 不能作为一个字符串的有效下标。  </p>
<p>如果 <code>String</code> 是空串，<code>startIndex</code> 与 <code>endIndex</code> 相等且都等于 <code>0</code>。   </p>
<hr>
<p>通过调用 <code>String</code> 的 <code>index(before:)</code> 和 <code>index(after:)</code> 函数可以立即得到前面一个或后面一个索引。<br>还可以通过调用 String 的 index(_:offsetBy:) 函数来获取对应偏移量的索引。  </p>
<p>有了索引之后，可以通过下标语法来获取对应索引位置的 <code>Character</code>。  </p>
<pre><code class="ObjC">let name = <span class="string">"Todd"</span>

name[name.startIndex]  <span class="comment">// T</span>
name[name.endIndex]  <span class="comment">// 报错</span>

let aIndex = name.index(after: name.startIndex)
let bIndex = name.index(before: name.endIndex)
name[aIndex]  <span class="comment">// o</span>
name[bIndex]  <span class="comment">// d</span>

let cIndex = name.index(name.startIndex, offsetBy:<span class="number">2</span>)
name[cIndex]  <span class="comment">// d</span>
</code></pre>
<hr>
<p>使用 <code>characters</code> 属性的 <code>indices</code> 属性会创建一个包含全部索引的范围，用来在一个字符串中访问单个字符。  </p>
<pre><code class="ObjC"><span class="keyword">for</span> index <span class="keyword">in</span> name.characters.indices {
   print(name[index])
}
</code></pre>
<hr>
<p>你可以使用 <code>startIndex</code> 和 <code>endIndex</code> 属性以及 <code>index(before:)</code>、<code>index(after:)</code> 和 <code>index(_:offsetBy:)</code> 函数在任意一个遵循 <code>Collection</code> 协议的类型里面，如上面的 <code>String</code>，也可以使用在 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中。  </p>
<hr>
<p>调用 <code>insert(_:at:)</code> 函数可以在一个字符串的指定索引位置插入一个字符。<br>调用 <code>insert(contentsOf:at:)</code> 函数可以在一个字符串的指定索引位置插入一个字符串。  </p>
<pre><code class="ObjC">var string = <span class="string">"Hello"</span>
string.insert(<span class="string">"!"</span>, at: string.endIndex)  <span class="comment">// Hello!</span>
string.insert(contentsOf: <span class="string">" Todd"</span>.characters, 
                      at: string.index(before: string.endIndex))  <span class="comment">// Hello Todd!</span>
</code></pre>
<hr>
<p>调用 remove(at:) 函数可以在一个字符串的指定索引位置删除一个字符。<br>调用 removeSubrange(_:) 函数可以在一个字符串的指定索引范围删除一个字符串。  </p>
<pre><code class="ObjC">var string = <span class="string">"Hello!"</span>
string.remove(at: string.index(before: string.endIndex))  <span class="comment">// Hello</span>

let range = string.startIndex...string.index(string.startIndex, offsetBy: <span class="number">2</span>)
string.removeSubrange(range)  <span class="comment">// lo</span>
</code></pre>
<hr>
<p>你可以使用 <code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code> 函数以及 <code>remove(at:)</code>、<code>removeSubrange(_:)</code> 函数在任意一个遵循 <code>RangeReplaceableCollection</code> 协议的类型里面，如上面的 <code>String</code>，也可以使用在 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中。   </p>
<hr>
<p>字符串/字符可以用等于操作符 <code>==</code> 和不等于操作符 <code>!=</code>。   </p>
<p>如果两个字符串/字符的可扩展字符群集是标准相等的，那就认为它们是相等的。因此，即使可扩展字符群集是由不同的 <code>Unicode</code> 标量组成，只要它们具有同样的语言意义和外观，就认为他们标准相等。  </p>
<pre><code class="ObjC">let a = <span class="string">"caf\u{00E9}"</span>
let b = <span class="string">"caf\u{0065}\u{0301}"</span>
a == b  <span class="comment">// true</span>
</code></pre>
<hr>
<p>通过调用 <code>hasPrefix(_:)</code> 和 <code>hasSuffix(_:)</code> 函数来检查字符串中是否拥有特定的前缀和后缀。  </p>
<p><code>hasPrefix(_:)</code> 和 <code>hasSuffix(_:)</code> 函数是在每个字符串中逐个字符比较其可扩展的字符群集是否标准相等。  </p>
<hr>
<p>Swift提供了三种方式来访问字符串的 <code>Unicode</code> 表示形式：  </p>
<ul>
<li>UTF-8，利用字符串的 <code>utf8</code> 属性进行访问。  </li>
<li>UTF-16，利用字符串的 <code>utf16</code> 属性访问。  </li>
<li>UTF-32，也就是 <code>Unicode</code> 标量。利用字符串的 <code>unicodeScalars</code> 属性访问。   </li>
</ul>
<hr>
<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><hr>
<p>Swift语言提供了 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 这三种基本的集合类型来存储数据。<br>数组 <code>Array</code> 是有序数据的集，字典 <code>Dictionary</code> 无序键值对的集，集合 <code>Set</code> 是无序无重复数据的集。  </p>
<hr>
<p><code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中存储的数据值类型必须明确。这意味着我们不能把不正确的数据类型放入其中，同时也说明了我们完全可以对取回的值的类型非常自信。  </p>
<hr>
<p>在我们不需要改变集合的时候尽量应该创建不可变集合，这样不仅可以有更好的性能优化，还能更加清晰的表达你的意图。  </p>
<hr>
<p>写Swift数组应该遵循像 <code>Array&lt;Element&gt;</code> 这样的形式，其中 <code>Element</code> 是这个数组中唯一允许存在的数据类型。也可是使用 <code>[Element]</code> 这样的简单语法。在实际编写代码的过程中，推荐使用 <code>[Element]</code> 这种写法。   </p>
<hr>
<p>创建一个空数组的两种常见的形式：   </p>
<pre><code class="ObjC">var someInts = [Int]()
var someInts: [Int] = []
</code></pre>
<hr>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/18/005-Hexo-GitHub/" rel="next" title="HEXO+GitHub搭建个人博客">
                <i class="fa fa-chevron-left"></i> HEXO+GitHub搭建个人博客
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Todd Cheng" />
          <p class="site-author-name" itemprop="name">Todd Cheng</p>
          <p class="site-description motion-element" itemprop="description">古佛中的逗逼佛</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Todd2010" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/todd2010" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础部分"><span class="nav-number">1.</span> <span class="nav-text">基础部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本运算符"><span class="nav-number">2.</span> <span class="nav-text">基本运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串和字符"><span class="nav-number">3.</span> <span class="nav-text">字符串和字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合类型"><span class="nav-number">4.</span> <span class="nav-text">集合类型</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Todd Cheng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
